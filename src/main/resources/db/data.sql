INSERT INTO game (question, answer) VALUES ('Какой цвет у неба?', 'Голубой');
INSERT INTO game (question, answer) VALUES ('Как твое имя?', 'Javanda');
INSERT INTO game (question, answer) VALUES ('Как настроение?', 'Good!!!');

-- src/main/resources/db/db.db.migration/core_1.sql
-- СORE-1
INSERT INTO answers_core1 (answer) VALUES (
'ООП - методология программирования, где программа может быть представлена в виде совокупности объектов,
каждый из которых является экземпляром определенного класса, и эти классы образуют иерархию наследования.
Согласно парадигме ООП программа состоит из обьектов, которые могут обмениваться сообщениями.
Обьекты могут обладать состоянием, и единственный способ изменить состояние обьекта - передать ему сообщение.
И в ответ на это сообщение обьект может изменить свое собственное состояние.
Класс — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора.
Объект – это экземпляр класса, созданный на основе этого описания(т.е. класса).'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое ООП?', 1);

INSERT INTO answers_core1 (answer) VALUES (
'Легко читается - не нужно выискивать в коде функции и выяснять, за что они отвечают.
Быстро пишется - можно быстро создать сущности, с которыми должна работать программа.
Простота реализации большого функционала - т.к. на написание кода уходит меньше времени, можно быстро создать
приложение с множеством возможностей. Меньше повторений кода - не нужно писать однотипные функции для разных сущностей.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какие преимущества у ООП?', 2);

INSERT INTO answers_core1 (answer) VALUES (
'Снижает производительность - потому что многие вещи технически реализованы иначе, поэтому они используют больше ресурсов.
Сложно начать - парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какие недостатки у ООП?', 3);

INSERT INTO answers_core1 (answer) VALUES (
'Инкапсуляция, Наследование, Полиморфизм. (Абстракция).'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Назовите основные принципы ООП.', 4);

INSERT INTO answers_core1 (answer) VALUES (
'Свойство системы, которое объединяет(инкапсулирует) данные и методы. И эти методы могут манипулировать этими данными,
а также защищает и то, и другое от внешнего вмешательства или неправильного использования.
То есть: Инкапсуляция - это объединение данных и методов для работы с этими данными в одной упаковке (капсуле).'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое инкапсуляция?', 5);

INSERT INTO answers_core1 (answer) VALUES (
'Свойство системы, которое позволяет описать новый класс на основе уже существующего с частичной или полностью заимствованной функциональностью.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое наследование?', 6);

INSERT INTO answers_core1 (answer) VALUES (
'Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
 Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса
 для задания единого набора действий. А выбор какого-то конкретного действия, возлагается на компилятор языка программирования,
 в зависимости от ситуации. Отсюда следует ключевая особенность полиморфизма - обращение к объектам может производиться по ссылке
 родительского типа).'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое полиморфизм?', 7);

INSERT INTO answers_core1 (answer) VALUES (
'Ассоциация - обозначает связь между обьектами. Например, игрок играет в определенной команде.
 Ассоциация означает, что объекты двух классов могут ссылаться один на другой, иметь некоторую связь между друг другом.
 Например: Менеджер может выписать Счет.
 Соответственно возникает ассоциация между Менеджером и Счетом.
 Еще пример — Преподаватель и Студент — т.е. какой-то Студент учится у какого-то Преподавателя.
 То есть ассоциация это описание связи между двумя объектами. Идея достаточно простая — два объекта могут быть
 связаны между собой и это надо как-то описать.');
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое ассоциация?', 8);

INSERT INTO answers_core1 (answer) VALUES (
'Композиция — еще более жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то.
Например Машина и Двигатель. Хотя двигатель может быть и без машины,
но он вряд ли сможет быть в двух или трех машинах одновременно.
В отличии от студента, который может входить и в другие группы тоже.
Например, класс автомобиля содержит объект класса электрического двигателя.
При этом класс автомобиля полностью управляет жизненным циклом объекта двигателя. При уничтожении объекта автомобиля в
области памяти вместе с ним будет уничтожен и объект двигателя. И в этом плане объект автомобиля является главным,
а объект двигателя - зависимой.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое композиция?', 9);

INSERT INTO answers_core1 (answer) VALUES (
'Агрегация определяет отношение Has a (англ. Имеет), но связь слабее чем в композиции, т.к. обьекты равноправны.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое агрегация?', 10);

INSERT INTO answers_core1 (answer) VALUES (
'Связывание есть наличие связи между вызываемым методом программы и написанным кодом.
"Ранее свзязывание означает что - если метод известен компилятору, то происходит ранее связывание на этапе компиляции (early binding),
также называют статическим связыванием.
Позднее связывание (late binding) означает что - вызов метода возможен только во время выполнения, т.к. у компилятора
нет информации, чтобы проверить корректность такого вызова. В java это возможно при помощи рефлексии.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое раннее и позднее связывание?', 11);

INSERT INTO answers_core1 (answer) VALUES (
'SOLID — это акроним, образованный из заглавных букв пяти принципов ООП и проектирования.
* S(Single Responsibility Principle) - принцип единственной ответственности - каждый класс выполняет лишь одну задачу.
Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы.
* O(Open Closed Principle) - принцип открытости/закрытости - программные сущности открыты для расширения и закрыты для
модификации.
Чтобы не сломать логику в классе-родителе, мы унаследуемся от него и реализуем что-то своё, и используем свой класс.
* L(Liskov’s Substitution Principle) - принцип подстановки Барбары Лисков -  объекты в программе можно заменить их
наследниками без изменения свойств программы.
* I(Interface Segregation Principle) - принцип разделения интерфейса. Много специализированных интерфейсов лучше, чем
один общий.
* D(Dependency Inversion Principle) - принцип инверсии зависимостей. Зависимость на абстракциях.
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Принципы SOLID.', 12);

INSERT INTO answers_core1 (answer) VALUES (
'Написано однажды - работает везде!
Данная идея основывается в написании одного кода, который будет работать на любой платформе.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какая основная идея языка?', 13);

INSERT INTO answers_core1 (answer) VALUES (
'Кроссплатформенность была достигнута за счёт создания виртуальной машина Java.
Java Virtual Machine или JVM - это программа, являющаяся прослойкой между операционной системой и Java программой.
В среде виртуальной машины выполняются коды Java программ. Сама JVM реализована для разных ОС.
И поэтому байт-код для JVM может исполняться везде где установлена JVM,
и его не нужно перекомпилировать под каждую из платформ.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('За счет чего обеспечивается кроссплатформенность?', 14);

INSERT INTO answers_core1 (answer) VALUES (
'Объектно-ориентированное программирование: Структура данных становится объектом, которым можно управлять для создания
отношений между различными объектами.
- Язык высокого уровня с простым синтаксисом и плавной кривой обучения: Синтаксис Java основан на C++, поэтому Java похожа на C.
Тем не менее, синтаксис Java проще, что позволяет новичкам быстрее учиться и эффективнее использовать код для достижения
конкретных результатов.
- Независимость от платформы: Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой
другой платформе, поддерживающей виртуальную машину Java (JVM). Таким образом,
JVM служит уровнем абстракции между кодом и оборудованием.
- Автоматическое управление памятью:
Разработчикам Java не нужно вручную писать код для управления памятью благодаря
автоматическому управлению памятью (AMM).
- Многопоточность:
Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать время процессора, Java позволяет
запускать потоки одновременно, что называется многопоточностью.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какие преимущества у Java?', 15);

INSERT INTO answers_core1 (answer) VALUES (
'- Платное коммерческое использование (с 2019 года).
- Низкая производительность из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти.
- Не развитые инструменты по созданию GUI приложений на чистой java.
- Многословный код, который вынуждает программистов прописывать свои действия словами из
 английского языка. Это делает язык более понятным для неспециалистов, но менее компактным.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какие недостатки у Java?', 16);

INSERT INTO answers_core1 (answer) VALUES (
'JDK (Java Development Kit) - включает JRE и набор инструментов разработчика приложений на языке Java:
* компилятор Java (javac).
* стандартные библиотеки классов java.
* примеры.
* документацию.
* различные утилиты.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое JDK? Что в него входит?', 17);

INSERT INTO answers_core1 (answer) VALUES (
'JRE (java Runtime Environment) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений.
Состоит из JVM, ClassLoader(загрузчик классов, который динамически загружает классы Java в JVM) и стандартного набора
библиотек и классов Java.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое JRE? что в него входит?', 18);

INSERT INTO answers_core1 (answer) VALUES (
'JVM (Java Virtual Machine) - виртуальная машина Java, которая исполняет байт-код Java, (предварительно созданный из
 кода JIT компилятором) с помощью встроенного интерпретатора байткода
 HotSpot представляет собой реализацию концепции JVM.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое JVM?', 19);

INSERT INTO answers_core1 (answer) VALUES (
'Байт-код Java — набор инструкций, скомпилированный компилятором и исполняемый JVM.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое byte code?', 20);

INSERT INTO answers_core1 (answer) VALUES (
'Используется для передачи в JVM скомпилированного байт-кода, хранится в файлах с расширением .class.
При запуске JVM, используются три загрузчика классов:
* Bootstrap ClassLoader - базовый загрузчик
- загружает классы платформы JDK из архива rt.jar.
* Extension ClassLoader - загрузчик расширений
- загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.
* AppClassLoader - системный загрузчик
- загружает классы приложения, определенные в CLASSPATH.
ClassLoader выполняет три основных действия в строгом порядке:
• Загрузка: находит и импортирует двоичные данные для типа.
• Связывание: выполняет проверку, подготовку и (необязательно) разрешение.
- Проверка: обеспечивает правильность импортируемого типа.
- Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.
- Разрешение: преобразует символические ссылки из типа в прямые ссылки.
• Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.
Каждый загрузчик хранит указатель на родительский, чтобы суметь передать загрузку если сам будет не в состоянии этого сделать.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое загрузчик классов (classloader)?', 21);

INSERT INTO answers_core1 (answer) VALUES (
'JIT (Just-in-time compilation) - компиляция на лету или динамическая компиляция. Это такая технология увеличения
 производительности программных систем,
 путем компиляции байт-кода в машинный код, прямо во время работы программы.
 В основном - отвечает за оптимизацию производительности приложений во время их выполнения.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое JIT?', 22);

INSERT INTO answers_core1 (answer) VALUES (
'Сборщик мусора выполняет две задачи:
* Поиск мусора и очистку мусора.
Для обнаружения мусора есть два подхода:
- Учет(Подсчет) ссылок (Reference counting);
Это означает что - если обьект не имеет ссылок, он считается мусором.
Проблема заключается в том, что при таком подходе нет возможности выявить циклические ссылки, т.е. когда два обьекта не имеют
внешних ссылок, но зато  ссылаются друг на друга. В следствии чего происходит -> утечка памяти.
- Трассировка (Tracing). (используется в HotSpot 6)  >> HotSpot - это одна из реализаций JVM.
Это означает что - до обьекта можно добраться из Корневых точек (GC root).
А до чего нельзя будет добраться - будет считаться мусором.
>> Корневые точки - это объекты или ссылки, которые создаются непосредственно в выполняемом коде.
И всё, что доступно из «живого»(используемого) объекта, также является «живым». (т.е., как я понял - живой объект это объект
на который имеется ссылка).
Типы корневых точек (GC Roots) java приложения:
- объекты в статических полях классов
- объекты, доступные из стека потоков
- объекты из JNI(java native interface) ссылок в native методах.
Существует 4 типа корневых точки:
• Локальные переменные и параметры методов;
• Потоки;
• Статические переменные;
• Ссылки из JNI.
Самое простое java приложение будет иметь следующие корневые точки:
• Локальные переменные внутри метода main(), и параметры метода main();
• Поток который выполняет метод main();
• Статические переменные класса, внутри которого находится метод main().
Процессы сборки мусора разделяются на несколько видов:
* minor GC (малая) - частая и быстрая сборка мусора. Работает только с областью памяти \"Young generation\".
- приложение приостанавливается на начало сборки мусора (такие остановки называются stop-the-world);
- «живые» объекты из Eden перемещаются в область памяти «To Space» (или как я понял в Survival Space);
- «живые» объекты из «From Space» перемещаются в «To Space» или в «Old generation», если они достаточно «старые»;
- Eden и «From Space» очищаются от мусора;
- «To Space» и «From Space» меняются местами;
- приложение возобновляет работу.
* major GC (старшая) - редкий и более длительный, затрагивает объекты старшего поколения.
В принцип работы «major GC» добавляется специальная процедура «уплотнения», позволяющая более эффективно использовать память.
И в этой процедуре живые объекты перемещаются в начало. Таким образом, мусор остается в конце памяти.
* full GC (полная) -  полный сборщик мусора сначала запускает Minor, а затем Major (хотя порядок может быть изменен, если
старое поколение заполнено, и в этом случае он освобождается первым,
чтобы позволить ему получать объекты от молодого поколения).
>> По информации из сайта JavaRush. Куча, где хранятся все созданные объекты, делится на несколько частей:
>> Yung Generation и Old Generation.
>> Yung Generation - делится на Eden(Райский сад) и Survival Space(Место для выжиыших). Survival Space делится на 5 разделов
для каждого поколения.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое сборщик мусора? (Garbage collector)', 23);

INSERT INTO answers_core1 (answer) VALUES (
'Память процесса делится на Stack (стек) и Heap (куча) :
* Stack содержит staсk-frame-ы, которые делятся на три части: параметры метода, указатель на предыдущий фрейм и локальные переменные.
* Структура Heap будет зависеть от выбранного сборщика мусора.
- Размер памяти стека, меньше памяти кучи. Стековая память быстрее памяти кучи.
- Heap - используется всем приложением, Stack - одним потоком исполняемой программы.
- Обьекты в куче доступны из любого места программы, стековая память не доступна для других потоков.
- Новый обьект создается в heap, в stack размещается ссылка на него. В стеке обычно размещаются локальные переменные
примитивных типов.
- Если память стека закончилась JRE вызовет исключение StackOverflowError, если куча заполнена OutOfMemoryError.
- В куче есть ссылки между объектами и их классами. На этом основана рефлексия.
Обе области хранятся в RAM.
С помощью опций Xms и Xmx можно настроить начальный и максимально допустимый размер кучи соответственно.
Также существуют опции для настройки величины стека.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое Heap и Stack память в Java? Чем они отличаются?', 24);

INSERT INTO answers_core1 (answer) VALUES (
'Целочисленные, Вещественные, Логические и Строковые.
* byte   = 8 бит  , от -128 до 127
* short  = 16 бит , от -32768 до 32767
* int    = 32 бит , от -2147483648 до 2147483647
* long   = 64 бит , от -9223372036854775808L до 9223372036854775807L
* float  = 32 бит , от 1.4e-45f до 3.4e+38f
* double = 64 бит , от 4.9e-324 до 1.7e+308
* char   = 16 бит , от 0 до 65536
* boolean = 8 бит в массиве, и 32 бита в остальных случаях.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какие примитивные типы данных есть в Java?', 25);

INSERT INTO answers_core1 (answer) VALUES (
'16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры).'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое char?', 26);

INSERT INTO answers_core1 (answer) VALUES (
'Это зависит от реализации JVM.
В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int.
Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Сколько памяти занимает boolean?', 27);

INSERT INTO answers_core1 (answer) VALUES (
'Класс-обертка — это специальный класс, который хранит внутри себя значение примитива(объекты классов-оберток являются неизменяемыми (Immutable)).
Нужны для реализации дженериков.
Классы-обёртки были придуманы для того, чтобы иметь возможность оперировать с простыми числами (и boolean) как с объектами.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое классы-обертки?', 28);

INSERT INTO answers_core1 (answer) VALUES (
'- Автоупаковка — это преобразование примитивных типов в эквивалентные объекты.
 - Автораспаковка — это преобразование объектов в соответствующие им примитивные типы.
 Для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое автоупаковка и автораспаковка?', 29);

INSERT INTO answers_core1 (answer) VALUES (
'Неявное приведение - автоматическое расширение типа переменной от меньшего к большему.
 Явное приведение - явное сужение от большего к меньшему. Необходимо явно указать сужаемый тип.
В случае с объектами мы можем делать неявное(автоматическое) приведение от наследника к родителю, но не наоборот,
иначе получим ClassCastException.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?', 30);

INSERT INTO answers_core1 (answer) VALUES (
'В Java есть пул(pool) целых чисел в промежутке [-128;127], так как это самый часто встречающийся диапазон.
Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое пул интов?', 31);

INSERT INTO answers_core1 (answer) VALUES (
'Класс String в Java — является неизменяемым из-за модификатора final и отсутствия сеттера. Это нужно для реализации пула стрингов.
При редактировании будет создаваться новая строка. При копировании новая строка не создается, а создается ссылка на существующую строку.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какие нюансы у строк в Java?', 32);

INSERT INTO answers_core1 (answer) VALUES (
'Пул строк это - область памяти где хранятся обьекты строк.
При создании в пуле идет поиск строки:
- если не находит - то создается строка, и возращается ссылка.
- если находит - то возращает ссылку найденной строки.
При этом использование оператора new заставляет класс String создать новый объект, даже если такая строка уже есть в пуле.
После этого можем использовать метод intern(), чтобы поместить этот объект в пул строк.

Пул строк как и пул int-ов хранятся в Heap-е, но ссылки на объекты хранятся в stack.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое пул строк?', 33);

INSERT INTO answers_core1 (answer) VALUES (
'- Т.к. строка неизменяемый класс, то будет большое потребление ресурсов при редактировании.
 - Т.к. каждую итерацию при редактировании будет создаваться новый обьект строки.
Рекомендуется использовать StringBuilder или StringBuffer.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?', 34);

INSERT INTO answers_core1 (answer) VALUES (
'1. Пул строк.
Так как строки в Java хранятся в пуле строк, то ваш пароль в виде обычного текста будет доступен в памяти, пока сборщик мусора не очистит её.
И поскольку String используются в String pool для повторного использования, существует довольно высокая вероятность того, что пароль останется в памяти надолго, что совсем не безопасно.
2. Рекомендации авторов.
Java сама по себе рекомендует использовать метод getPassword () из класса JPasswordField, который возвращает char [].
3. Случайная печать в логах.
С типом String всегда существует опасность того, что текст, хранящийся в строке будет напечатан в файле логов или в консоли.
В то же время в случае использования Array, вы не будете печатать содержимое массива, а только его расположение в памяти.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Почему строки не рекомендуется использовать для хранения паролей?', 35);

INSERT INTO answers_core1 (answer) VALUES (
'1. Для возможности реализации строкового пула (String pool).
Виртуальная машина имеет возможность сохранить много места в памяти (heap space) т.к. разные строковые переменные указывают на одну переменную в пуле.
При изменяемости строк было бы невозможно реализовать интернирование, поскольку если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.
2. Безопасность.
Изменяемость строк несло бы в себе потенциальную угрозу безопасности приложения. Поскольку в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. — неизменяемость позволяет избежать проблем с доступом.
3. Для многопоточности. Неизменяемые строки потокобезопасны.
Так как строка неизменяемая то, она безопасна для много поточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности. Таким образом, строки в Java полностью потокобезопасны.
4. Ключ для HashMap.
Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет никакой необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Поэтому строка наиболее часто используется в качестве ключа HashMap.

В итоге:
- можно передавать строку между потоками не опасаясь, что она будет изменена.
- отсутствуют проблемы с синхронизацией потоков.
- отсутствие проблем с  утечкой памяти.
- отсутствие проблем с доступом и безопасностью при использовании строк для передачи параметров авторизации, открытия файлов и т.д.
- кэширование hashcode.
- экономия памяти при использовании пула строк для хранения повторяющихся строк.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Почему String неизменяемый и финализированный класс?', 36);

INSERT INTO answers_core1 (answer) VALUES (
'Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Почему строка является популярным ключом в HashMap в Java?', 37);

INSERT INTO answers_core1 (answer) VALUES (
'Помещает строку в pool строк. (Например, если мы создали новую строку с помощью оператора new).'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что делает метод intern() в классе String?', 38);

INSERT INTO answers_core1 (answer) VALUES (
'Да, начиная с Java 7 в операторе switch можно использовать строки, ранние версии Java не поддерживают этого.
При этом:
- участвующие строки чувствительны к регистру;
- использование строк в конструкции switch делает код читабельнее, убирая множественные цепи условий if-else
- оператор switch использует метод String.equals() для сравнения полученного значения со значениями case, поэтому добавьте проверку на NULL во избежание NullPointerException.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Можно ли использовать строки в конструкции switch?', 39);

INSERT INTO answers_core1 (answer) VALUES (
'* String - неизменяемый, потокобезопасный.
 * StringBuffer - изменяемый, потокобезопасный.
 * StringBuilder - изменяемый, потоконебезопасный.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какая основная разница между String, StringBuffer, StringBuilder?', 40);

INSERT INTO answers_core1 (answer) VALUES (
'Многомерные массивы в их классическом понимании в Java не существуют.
 Многомерный массив всегда прямоугольный и неразрывен в памяти.
А то, что в Java считается мнoгомерным - в других языках ещё называют "зубчатым массивом" или массивом массивов.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Существуют ли в Java многомерные массивы?', 41);

INSERT INTO answers_core1 (answer) VALUES (
'- byte    = 0
 - short   = 0
 - int     = 0
 - long    = 0L
 - float   = 0.0f
 - double  = 0.0d
 - char    = \u0000
 - boolean = false
 - Обьекты = null
Локальные (в методе) переменные не имеют значений по умолчанию, их имеют только поля класса.
Не static-поле класса будет инициализировано после того, как будет создан объект этого класса.
А  static-поле будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какими значениями инициируются переменные по умолчанию?', 42);

INSERT INTO answers_core1 (answer) VALUES (
'- Это имя метода плюс параметры (порядок параметров имеет значение из-за множественной передачи данных через троеточие, которое должно располагаться последним).
В сигнатуру метода не входит возвращаемое значение, и не входит бросаемые им исключения.
А сигнатура метода в сочетании с типом возвращаемого значения и бросаемыми исключениями называется контрактом метода.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое сигнатура метода?', 43);

INSERT INTO answers_core1 (answer) VALUES (
'Является, как правило, точкой входа в программу и вызывается JVM.
Как только заканчивается выполнение метода main(), так сразу же завершается работа самой программы.
static - чтобы JVM смогла загрузить его во время компиляции.
public static void и сигнатура - это обязательное декларирование.
Мэйнов может быть много и может не быть вообще.
Также может быть перегружен.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Расскажите про метод main().', 44);

INSERT INTO answers_core1 (answer) VALUES (
'- Java передает параметры по значению. Всегда.
С примитивами, мы получаем копию содержимого. Со ссылками мы тоже получаем копию ссылки.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Каким образом переменные передаются в методы, по значению или по ссылке?', 45);

INSERT INTO answers_core1 (answer) VALUES (
'1. Вложенные(Nested) классы – нестатические классы внутри внешнего класса.
2. Вложенные(Nested) статические классы – статические классы внутри внешнего класса.
3. Локальные классы Java – классы внутри методов. Есть разница между локальным и внутреним.
4. Анонимные Java классы – классы, которые создаются на ходу. Анонимные классы доступно.
5. Final, abstract, enum - классы.

К классам верхнего уровня модификатор static неприменим. '
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какие виды классов есть в Java?', 46);

INSERT INTO answers_core1 (answer) VALUES (
'- Вложенные классы нужны для обслуживания внешних классов.
1. Статические вложенные классы (Static nested classes).
- Есть возможность обращения к внутренним статическим полям и методам класса обертки.
2. Вложенные классы.
- Есть возможность обращения к внутренним полям и методам класса обертки.
- Не может иметь статических объявлений.
- Внутри такого класса нельзя объявить перечисления.
- Если нужно явно получить this внешнего класса — OuterClass.this;
3. Локальный класс.
- Видны только в пределах блока, в котором объявлены.
- Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально).
- Не могут иметь внутри себя статических объявлений (полей, методов, классов), но могут иметь константы (static final).
-Имеют доступ к полям и методам обрамляющего класса.
- Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final или являются effectively final.
4. Анонимные классы.
- Локальный класс без имени.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Расскажите про вложенные классы. В каких случаях они применяются?', 47);

INSERT INTO answers_core1 (answer) VALUES (
'Данные классы объявляются внутри других методов. Они обладают всеми свойствами нестатического вложенного класса, но только создавать их экземпляры можно только внутри метода.
Особенности:
- Локальные классы способны работать только с final переменными метода.
- С 8+ версий Java можно использовать не final переменные в локальных классах, но только при условии, что они не будут изменяться.
- Локальные классы нельзя объявлять с модификаторами доступа.
- Локальные классы обладают доступом к переменным метода.
- Может быть создан внутри блоков инициализации.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое «локальный класс»? Каковы его особенности?', 48);

INSERT INTO answers_core1 (answer) VALUES (
'- Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений.
Создание экземпляра анонимного класса происходит одновременно с его объявлением.
В зависимости от местоположения анонимный класс может вести себя как статический либо как нестатический вложенный класс.

Анонимные классы имеют несколько ограничений:
- Их использование разрешено только в одном месте программы - месте его создания;
- Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
- Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять новых методов, так как для доступа к ним нет поименованного типа.
- Анонимные классы обычно применяются для:

* создания объекта функции (function object), например реализация интерфейса Comparator;
* создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
* в статическом методе генерации;
* инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.

- Анонимные классы всегда являются конечными классами.
- Каждое объявление анонимного класса уникально.
- Видны только внутри того метода, в котором определены.

В документации Oracle приведена хорошая рекомендация: «Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования». '
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое «анонимные классы»? Где они применяются?', 49);

INSERT INTO answers_core1 (answer) VALUES (
'- Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса.
- Простой вложенный класс, может обратиться к любому полю внешнего класса напрямую.
В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к внешнему полю следует через имя внешнего класса.
Например: Outer.this.field.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Каким образом из вложенного класса получить доступ к полю внешнего класса?', 50);

INSERT INTO answers_core1 (answer) VALUES (
'- Перечисления(Enum) - это набор логически связанных констант.
Перечисление фактически представляет новый класс, поэтому мы можем определить переменную данного типа и использовать ее.
Перечисления, как и обычные классы, могут определять конструкторы, поля и методы.
Следует отметить, что конструктор по умолчанию приватный.
Также можно определять методы для отдельных констант.
Методы:
- ordinal() возвращает порядковый номер определенной константы (нумерация начинается с 0).
- values() возвращает массив всех констант перечисления.
Еnum имеет ряд преимуществ при использовании в сравнении с static final int.
Главным отличием является то что используя enum вы можете проверить тип данных.
Недостатки:
- К ним не применимы операторы >, <, >=, <=
- Еnum также требует больше памяти для хранения чем обычная константа.
Нужны для ограничения области допустимых значений: например, времена года, дни недели.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое перечисления (enum)?', 51);

INSERT INTO answers_core1 (answer) VALUES (
'- В Java нет поддержки множественного наследования классов.
Предположим, что SuperClass — это абстрактный класс, описывающий некоторый метод, а классы ClassA и ClassB — обычные классы наследники SuperClass,
а класс ClassC наследуется от ClassA и ClassB одновременно.
Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, метод какого именно суперкласса должен быть вызван.
Это и есть основная причина, почему в Java нет поддержки множественного наследования классов.

>> В Java множественное наследование не поддерживается в классах, но оно поддерживается в интерфейсах. И один интерфейс может расширять множество других >> интерфейсов.

1. Классы всегда побеждают: Определенный в классе / суперклассе метод всегда имеет высший приоритет перед дефолтными методами интерфейсов.
2. Если не срабатывает правило 1, то побеждают саб-интерфейсы (more specific). Т.е. если интерфейс B наследует A, и у обоих есть методы с одинаковой сигнатурой, то побеждает B.
3. Если оба правила не работают, то класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать, иначе компилятор будет сильно материться.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Как проблема ромбовидного наследования решена в java?', 52);

INSERT INTO answers_core1 (answer) VALUES (
'Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов, так называемый «конструктор по умолчанию».
Если же у класса уже определен какой-либо конструктор, то конструктор по умолчанию создаваться не будет и если он необходим, его нужно описывать явно.
Создавая объект посредством конструктора без параметра, вы просто инициализируете его поля и выделяете память под этот объект.
То есть в памяти появится ссылка на этот объект, о котором пока ничего не будет известно.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое конструктор по умолчанию?', 53);

INSERT INTO answers_core1 (answer) VALUES (
'- Да, могут. Приватный конструктор запрещает создание экземпляра класса вне методов самого класса.
Нужен для реализации паттернов, например Singleton.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Могут ли быть приватные конструкторы? Для чего они нужны?', 54);

INSERT INTO answers_core1 (answer) VALUES (
'- При запуске JVM, используются три загрузчика классов:
* Bootstrap ClassLoader - главный загрузчик
 - загружает платформенные классы JDK из архива rt.jar.
* Extension ClassLoader - загрузчик расширений
- загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.
* AppClassLoader - системный загрузчик
 - загружает классы приложения, определенные в CLASSPATH.

Динамическая загрузка происходит "на лету" в ходе выполнения программы с помощью статического метода класса Class.forName(имя класса).

Для чего нужна динамическая загрузка?
- Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Расскажите про классы-загрузчики и про динамическую загрузку классов.', 55);

INSERT INTO answers_core1 (answer) VALUES (
'- У конструктора по умолчанию отсутствуют какие-либо аргументы.
- Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона.
- Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?', 56);

INSERT INTO answers_core1 (answer) VALUES (
'- Private – доступ к компоненту только из этого класса, в котором объявлен.
- Default – Переменная или метод будут доступны для любого другого класса в том же пакете.
- Protected – Поля protected доступны всем классам внутри пакета, а также всем классам-наследникам вне пакета.
- Public – доступ к компоненту из экземпляра любого класса и любого пакета.

Класс может быть объявлен с модификатором public и default.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какие модификаторы доступа есть в Java? Какие применимы к классам?', 57);

INSERT INTO answers_core1 (answer) VALUES (
'- Модификатор static в Java напрямую связан с классом.
Если поле статично, значит оно принадлежит классу, если метод статичный — аналогично: он принадлежит классу.
Исходя из этого, можно обращаться к статическому методу или полю, используя имя класса.
Например, если поле count статично в классе Counter, значит, вы можете обратиться к переменной запросом вида: Counter.count. '
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что означает модификатор static?', 58);

INSERT INTO answers_core1 (answer) VALUES (
'- Нет. Нельзя переопределять статические методы.
Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса  вместо переопределения. Это явление известно как сокрытие методов (hiding methods).
Перегружен - да, может.
Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Может ли статический метод быть переопределён или перегружен?', 59);

INSERT INTO answers_core1 (answer) VALUES (
'- Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Могут ли нестатические методы перегрузить статические?', 60);

INSERT INTO answers_core1 (answer) VALUES (
'- Сузить нельзя. При переопределении метода нельзя сузить модификатор доступа к методу (например, с public до private), НО МОЖНО РАСШИРИТЬ.
- Изменить тип возвращаемого значения нельзя, но можно сузить возвращаемое значение, но только если они совместимы.
Например, если метод возвращает объект класса, а переопределенный метод возвращает объект класса-наследника.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?', 61);

INSERT INTO answers_core1 (answer) VALUES (
'- В сигнатуре(имя + параметры) менять ничего нельзя.
Возможно расширение уровня доступа.
Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).
Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса.
Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException.
Порядок следования таких элементов при переопределении значения не имеет.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?', 62);

INSERT INTO answers_core1 (answer) VALUES (
'- Класс можно объявить статическим за исключением классов верхнего уровня.
Такие классы известны как «вложенные статические классы» (nested static class). '
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Могут ли классы быть статическими?', 63);

INSERT INTO answers_core1 (answer) VALUES (
'- Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование.
Следует также отметить, что к abstract-классам нельзя применить модификатор final, т.к. это взаимоисключающие понятия.
Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено.
Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект.
Важно: Ссылку изменить нельзя, но состояние объекта изменять можно.
Т.к. массив – это объект, то final означает, что после присвоения ссылки на объект, уже нельзя ее изменить, но можно изменять состояние объекта.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что означает модификатор final? К чему он может быть применим?', 64);

INSERT INTO answers_core1 (answer) VALUES (
'- Абстрактным называется класс, на основе которого не могут создаваться объекты.
Это как обычный класс, но с абстрактными методами.
Нельзя создать объект или экземпляр абстрактного класса.
Наследниками абстрактного класса могут быть другие абстрактные классы.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое абстрактные классы? Чем они отличаются от обычных?', 65);

INSERT INTO answers_core1 (answer) VALUES (
'- Класс может быть абстрактным без единого абстрактного метода, если у него указан модификатор abstract.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Может ли быть абстрактный класс без абстрактных методов?', 66);

INSERT INTO answers_core1 (answer) VALUES (
'- Да. Необходимы для наследников.
В абстрактном классе в Java можно объявить и определить конструкторы.
Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов.
Абстрактные конструкторы будут часто использоваться для обеспечения ограничений класса или инвариантов, таких как минимальные поля,
необходимые для настройки класса.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?', 67);

INSERT INTO answers_core1 (answer) VALUES (
'- Интерфейс — это план класса или, можно сказать, набор абстрактных методов и статических констант.
В интерфейсе каждый метод является открытым и абстрактным, но не содержит конструктора.
Таким образом, интерфейс в основном представляет собой группу связанных методов с пустыми телами.
Другими словами, интерфейс определяет как элементы будут взаимодействовать между собой.

- методы интерфейса являются публичными (public) и абстрактными (abstract),
- поля — public static final. '
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?', 68);

INSERT INTO answers_core1 (answer) VALUES (
'1. Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме public static final),
в то время как у абстрактного класса они могут быть.
2. Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.
3. Абстрактные классы используются, когда есть отношение "is-a", то есть когда класс-наследник расширяет базовый абстрактный класс,
а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.
4. Абстрактный класс может реализовывать методы; интерфейс может реализовывать дефолтные методы начиная с 8-й версии Java.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?', 69);

INSERT INTO answers_core1 (answer) VALUES (
'- Да, может. Используется ключевое слово extends'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Может ли один интерфейс наследоваться от другого? От двух других?', 70);

INSERT INTO answers_core1 (answer) VALUES (
'- В JDK-8 была добавлена такая функциональность как методы по умолчанию с модификатором default.
И теперь интерфейсы могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод.
Это нужно для обратной совместимости.

(Если один или несколько методов добавляются к интерфейсу, все реализации также будут вынуждены их реализовывать. Методы интерфейса по умолчанию являются эффективным способом решения этой проблемы).'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое дефолтные методы интерфейсов? Для чего они нужны?', 71);

INSERT INTO answers_core1 (answer) VALUES (
'- Класс, наследующий конфликтующие интерфейсы, должен явно через кл. слово super определить, какой именно метод вызвать:
 InterfaceB.super.method();'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?', 72);

INSERT INTO answers_core1 (answer) VALUES (
'1. Статические блоки от первого до последнего предка(от предка до наследника).
2. Попарно динамической блок инициализации и конструктор от первого до последнего предка.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?', 73);

INSERT INTO answers_core1 (answer) VALUES (
'- Инициализация - это когда мы впервые задаем переменной какое-либо значение.
Существуют статические и нестатические блоки инициализации.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Зачем нужны и какие бывают блоки инициализации?', 74);

INSERT INTO answers_core1 (answer) VALUES (
'- Статические блоки инициализации используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент предшествующий созданию объектов этого класса при помощи конструктора.
Такой блок принадлежит только самому классу.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Для чего в Java используются статические блоки инициализации?', 75);

INSERT INTO answers_core1 (answer) VALUES (
'- Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом, требуется, чтобы объявления этих исключений были
перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции.
- Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что произойдет, если в блоке инициализации возникнет исключительная ситуация?', 76);

INSERT INTO answers_core1 (answer) VALUES (
'- Если возникшее исключение - наследник RuntimeException:
* для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;
* для нестатических будет проброшено исключение-источник.
- Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error.
- Если исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено не будет.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?', 77);

INSERT INTO answers_core1 (answer) VALUES (
'- Базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы.
Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В результате объект Object может ссылаться на объект любого другого класса.
Рефлексия (от позднелат. reflexio - обращение назад) - это механизм исследования данных о программе во время её выполнения.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое класс Object?', 78);

INSERT INTO answers_core1 (answer) VALUES (
'- equals(); проверка на равенство двух обьектов.
- hashCode(); изначально случайно число int.
- toString(); представления данного объекта в виде строки.
- getClass(); получение типа данного обьекта.
- clone(); клонирует объект методом.
- finalize(); deprecated, вызывается GC перед удалением (нет гарантии что будет вызван).
А так-же для многопоточки:
- wait(); освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify().
- notify(); продолжает работу потока, у которого ранее был вызван метод wait().
- notifyAll(); возобновляет работу всех потоков, у которых ранее был вызван метод wait().
- wait(long timeOut); поток освобождает монитор и «становится на паузу», принимает максимальное время ожидания в миллисекундах.
- wait(long timeOut, int nanos); поток освобождает монитор и «становится на паузу», принимает максимальное время ожидания в миллисекундах, дополнительное время, в диапазоне наносекунд 0-999999.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какие методы есть у класса Object (перечислить все)? Что они делают?', 79);

INSERT INTO answers_core1 (answer) VALUES (
'- Хеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект.
Если более точно, то это битовая строка фиксированной длины, полученная из массива произвольной длины.
Equals — это метод, определенный в Object, который служит для сравнения объектов. При сравнении объектов при помощи == идет сравнение по ссылкам.
При сравнении по equals() идет сравнение по состояниям объектов.
Свойства equals():
• Симметричность: Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a).
• Рефлексивность: Для любого заданного значения x, выражение x.equals(x) должно возвращать true.
 Для заданного — имеется в виду такого, что x != null.
• Постоянство: Повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.
• Транзитивность: Если a.equals(b) и b.equals(c), то тогда a.equals(c).
• Совместимость с hashCode(): Два тождественно равных объекта должны иметь одно и то же значение hashCode().
При переопределении equals() обязательно нужно переопределить метод hashCode(). Равные объекты должны возвращать одинаковые хэш коды.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Расскажите про equals и hashcode.', 80);

INSERT INTO answers_core1 (answer) VALUES (
'1. Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:
public boolean equals(Object obj) {
	return (this == obj);
}
2. HashCode реализован таким образом, что для одного и того же входного объекта, хеш-код всегда будет одинаковым.
Реализация метода Object.hashCode() описана как native, т.е. написана не на Java.
Непереопределенный hashCode возвращает идентификационный хеш, основанный на состоянии потока, объединённого с xorshift (в OpenJDK8).
А вообще, функция предлагает шесть методов на базе значения переменной hashCode.

0. Случайно сгенерированное число.
1. Функция адреса объекта в памяти.
2. Жёстко запрограммированное значение 1 (используется при тестировании на чувствительность (sensitivity testing)).
3. Последовательность.
4. Адрес объекта в памяти, приведённый к целочисленному значению.
5. Состояние потока, объединённое с xorshift:                        public native int hashCode();

Ситуация, когда у разных объектов одинаковые хеш-коды называется — коллизией.
Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Каким образом реализованы методы hashCode() и equals() в классе Object?', 81);

INSERT INTO answers_core1 (answer) VALUES (
'- equals() делает сравнение по состоянию, - а знак == по ссылкам.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Зачем нужен equals()?', 82);

INSERT INTO answers_core1 (answer) VALUES (
'- Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать.
Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?', 83);

INSERT INTO answers_core1 (answer) VALUES (
'1. Если два объекта возвращают разные значения hashcode(), то они не могут быть равны.
2. Если equals объектов true, то и хэшкоды должны быть равны.
3. Переопределив equals, всегда переопределять и hashcode.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какой контракт между hashCode() и equals()?', 84);

INSERT INTO answers_core1 (answer) VALUES (
'Вычисляет целочисленное значение для конкретного элемента класса, чтобы использовать его для быстрого поиска и доступа к этому элементу в hash-структурах данных, например, HashMap, HashSet и прочих.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Для чего нужен метод hashCode()?', 85);

INSERT INTO answers_core1 (answer) VALUES (
'- Если хеш-коды разные, то и входные объекты гарантированно разные.
- Если хеш-коды равны, то входные объекты не всегда равны.
При вычислении хэш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений.
- вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.
- вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true).
- вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Правила переопределения метода hashCode().', 86);

INSERT INTO answers_core1 (answer) VALUES (
'- Выбирать поля, которые с большой долью вероятности будут различаться.
Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid.
При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?', 87);

INSERT INTO answers_core1 (answer) VALUES (
'- Когда у разных объектов одинаковые хеш-коды называется — коллизией.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Могут ли у разных объектов быть одинаковые hashCode()?', 88);

INSERT INTO answers_core1 (answer) VALUES (
'- В Java множество возможных хэш-кодов ограничено типом int, а множество объектов ничем не ограничено.
Из-за этого, вполне возможна ситуация, что хэш-коды разных объектов могут совпасть.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Почему нельзя реализовать hashCode(), который будет гарантированно уникальным для каждого объекта?', 89);

INSERT INTO answers_core1 (answer) VALUES (
'Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?', 90);

INSERT INTO answers_core1 (answer) VALUES (
'- getClass() получает только класс, а оператор instanceof проверяет является ли объект экземпляром класса или его потомком.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Чем a.getClass().equals(A.class) отличается от a instanceOf A.class ?', 91);

INSERT INTO answers_core1 (answer) VALUES (
'Исключение — это ошибка (является объектом), возникающая во время выполнения программы. '
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое исключения?', 92);

INSERT INTO answers_core1 (answer) VALUES (
'1. класс Throwable (checked).
2. от Throwable  -> Error (ошибки JVM) и Exception (checked общие).
3. от Exception
- > RuntimeException (unchecked)
- > IOException, SQLException, ReflectiveOperationException (checked).
4. RuntimeException (unchecked):
  ClassCastExceptiuon
  IndexOutOfBoundException
  AritthmeticException
  NullPointerException.

checked - зависит от программиста, unchecked - от программиста не зависит.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Опишите иерархию исключений.', 93);

INSERT INTO answers_core1 (answer) VALUES (
'1. Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода.
Unchecked могут не обрабатываться и не быть описанными.
2. Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception.
Checked исключения отличаются от Unchecked исключения в Java, тем что
Checked исключения проверяются компилятором на этапе компиляции.
А Unchecked исключения происходит на этапе выполнения.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Расскажите про обрабатываемые и необрабатываемые исключения.', 94);

INSERT INTO answers_core1 (answer) VALUES (
'- Можно, чтобы в некотрых случаях программа не прекратила работу.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Можно ли обработать необрабатываемые исключения?', 95);

INSERT INTO answers_core1 (answer) VALUES (
'- Throw.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какой оператор позволяет принудительно выбросить исключение?', 96);

INSERT INTO answers_core1 (answer) VALUES (
'- Метод потенциально может выбросить исключение с указанным типом.
Передаёт обработку исключения вышестоящему методу.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('О чем говорит ключевое слово throws?', 97);

INSERT INTO answers_core1 (answer) VALUES (
'- Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException), и переопределить методы.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Как создать собственное («пользовательское») исключение?', 98);

INSERT INTO answers_core1 (answer) VALUES (
'- Try - блок в котором может появиться исключение;
- Catch - блок в котором мы указываем исключение и логику его обработки;
- Finally - блок который обязательно отработает.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Расскажите про механизм обработки исключений в java (Try-catch-finally).', 99);

INSERT INTO answers_core1 (answer) VALUES (
'- try может быть в паре с finally, без catch. Работает это точно так же - после выхода из блока try выполняется блок finally.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Возможно ли использование блока try-finally (без catch)?', 100);

INSERT INTO answers_core1 (answer) VALUES (
'- Да.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Может ли один блок catch отлавливать сразу несколько исключений?', 101);

INSERT INTO answers_core1 (answer) VALUES (
'- Да, кроме случаев завершения работы программы или JVM:
1. Finally может не выполниться в случае если в блоке try вызывает System.exit(0),
2. Runtime.getRuntime().exit(0), Runtime.getRuntime().halt(0) и если во время исполнения блока try виртуальная машина выполнила недопустимую операцию и будет закрыта.
3. В блоке try{} бесконечный цикл.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Всегда ли выполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен?', 102);

INSERT INTO answers_core1 (answer) VALUES (
'- Может. И оно будет передано в виртуальную машину Java (JVM).
Для случая с методом main произойдет две вещи:
- будет завершен главный поток приложения;
- будет вызван ThreadGroup.uncaughtException.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?', 103);

INSERT INTO answers_core1 (answer) VALUES (
'- От наследника к предку.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('В каком порядке следует обрабатывать исключения в catch блоках?', 104);

INSERT INTO answers_core1 (answer) VALUES (
'- Дает возможность объявлять один или несколько ресурсов в блоке try, которые будут закрыты автоматически без использования finally блока.
В качестве ресурса можно использовать любой объект, класс которого реализует интерфейс java.lang.AutoCloseable или java.io.Closeable.

>>> Closeable это наследник AutoCloseable.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое механизм try-with-resources?', 105);

INSERT INTO answers_core1 (answer) VALUES (
'- finally-секция может «перебить» throw/return при помощи другого throw/return.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?', 106);

INSERT INTO answers_core1 (answer) VALUES (
'- В try-with-resources добавленна возможность хранения "подавленных" исключений, и брошенное try-блоком исключение имеет больший приоритет, чем исключения получившиеся во время закрытия.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?', 107);

INSERT INTO answers_core1 (answer) VALUES (
'- Сериализация это процесс сохранения состояния объекта в последовательность байт;
Реализована через интерфейс - маркер Serializable. '
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Что такое сериализация и как она реализована в Java?', 108);

INSERT INTO answers_core1 (answer) VALUES (
'- Для компактного сохранения состояния объекта и считывание этого состояния.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Для чего нужна сериализация?', 109);

INSERT INTO answers_core1 (answer) VALUES (
'Процесс сериализации:
1. Класс сериализуемого объекта должен реализовывать интерфейс Serializable.
2. Создать поток ObjectOutputStream (oos), который записывает объект в переданный OutputStream.
3. Записать в поток: oos.writeObject(Object);
4. Сделать oos.flush() и oos.close().
Для сериализации объектов в поток используется класс ObjectOutputStream. Он записывает данные в поток.
void writeObject(Object obj): записывает в поток отдельный объект.
void close(): закрывает поток.
void flush(): очищает буфер и сбрасывает его содержимое в выходной поток.

Для десериализации – ObjectInputStream.
Object readObject(): считывает из потока объект.
void close(): закрывает поток. '
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Опишите процесс сериализации/десериализации с использованием Serializable.', 110);

INSERT INTO answers_core1 (answer) VALUES (
'- Использовать интерфейс Externalizable.
- Переопределить методы:
* writeExternal(ObjectOutput out) throws IOException;
* readExternal(ObjectInput in) throws IOException, ClassNotFoundException;'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Как изменить стандартное поведение сериализации/десериализации?', 111);

INSERT INTO answers_core1 (answer) VALUES (
'1. Добавить к полю модификатор transient. В таком случае после восстановления его значение будет null.
2. Сделать поле static. Значения статических полей автоматически не сохраняются.
3. Поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно.
Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?', 112);

INSERT INTO answers_core1 (answer) VALUES (
'- Для создания собственного протокола нужно просто переопределить writeExternal() и readExternal().
В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках. '
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Как создать собственный протокол сериализации?', 113);

INSERT INTO answers_core1 (answer) VALUES (
'- Поле private static final long serialVersionUID - содержит уникальный идентификатор версии сериализованного класса.
Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления.
Соответственно, при любом изменении в классе это поле поменяет свое значение.
 Если мы не объявляем его явно, Java делает это за нас.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какая роль поля serialVersionUID в сериализации?', 114);

INSERT INTO answers_core1 (answer) VALUES (
'- Вы должны изменить serialVersionUID только тогда, когда вы сознательно хотите нарушить совместимость со всеми существующими сериализациями,
например, когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Когда стоит изменять значение поля serialVersionUID?', 115);

INSERT INTO answers_core1 (answer) VALUES (
'- Проблема:
В том что после десериализации мы получим другой объект.
Таким образом, сериализация дает возможность создать Singleton еще раз, что не совсем нужно.

- Решение:
В классе определяется метод с сигнатурой
"Object readResolve() throws ObjectStreamException"

// Назначение этого метода - возвращать замещающий объект вместо объекта, на котором он вызван.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('В чем проблема сериализации Singleton?', 116);

INSERT INTO answers_core1 (answer) VALUES (
'- В Java, есть 3 способа клонирования объекта:
1. С использованием интерфейса Cloneable;
Первый способ подразумевает, что вы будете использовать механизм так называемого «поверхностного клонирования» и сами позаботитесь
о клонировании полей-объектов.
Метод clone() в родительском классе Object является protected, поэтому требуется переопределение его с объявлением как public.
Он возвращает экземпляр объекта с копированными полями-примитивами и ссылками.
И получается что у оригинала и его клона поля-ссылки указывают на одни и те же объекты.
2. С использованием конструктора клонирования объекта;
В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта.
3. С использованием сериализации.
Он заключается в сохранении объекта в поток байтов с последующей эксгумацией его от туда.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Расскажите про клонирование объектов.', 117);

INSERT INTO answers_core1 (answer) VALUES (
'- Поверхностное копирование копирует настолько малую часть информации, насколько это возможно.
По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует.
- Глубокое копирование дублирует все. Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции. '
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('В чем отличие между поверхностным и глубоким клонированием?', 118);

INSERT INTO answers_core1 (answer) VALUES (
'- Наиболее безопасным и следовательно предпочтительным способом клонирования является использование специализированного конструктора копирования:
Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод clone());
Поля для клонирования указываются явно;
Возможность клонировать даже final поля.'
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Какой способ клонирования предпочтительней?', 119);

INSERT INTO answers_core1 (answer) VALUES (
'- Метод clone() объявлен в классе Object с сигнатурой native, чтобы обеспечить доступ к стандартному механизму "поверхностного копирования" объектов (копируются значения всех полей, включая ссылки на сторонние объекты);
Он объявлен, как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. '
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?', 120);

INSERT INTO answers_core1 (answer) VALUES (
'- Глубокое клонирование требует выполнения следующих правил:
* Нет необходимости копировать отдельно примитивные данные;
* Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться super.clone() при переопределении метода clone();
* Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.
Способы:
1. Сериализация – это еще один способ глубокого копирования. Мы просто сериализуем нужный объект и десериализуем его. Очевидно, объект должен поддерживать интерфейс Serializable. Мы сохраняет объект в массив байт и потом прочитать из него.
2. При помощи библиотеки DeepCloneable.
Глубокое клонирование с этой библиотекой сводится к двум строкам кода:
Cloner cloner = new Cloner();
DeepCloneable clone = cloner.deepClone(this);  '
);
INSERT INTO questions_core1 (question, answer_id) VALUES ('Как создать глубокую копию объекта? (2 способа).', 121);


-- src/main/resources/db/db.db.migration/core_2.sql
-- СORE-2
INSERT INTO answers_core2 (answer) VALUES (
'Дженерики — это такой набор свойств, с помощью которого можно определять и использовать обобщенные типы.
 Это когда мы зараннее не знаем какой тип будет указан. Т.е. когда тип указан в виде параметра.
 Эти параметры можно использовать в классах, интерфейсах и методах. Например мы можем создать какой-то класс,
 и он будет работать с разными типами данных, хотя при описании класса мы не указывали какой-то конкретный тип.
 То есть, перед созданием объекта какого-то класса или метода, мы как бы, сначала, параметризуем наш объект или метод.
 А информация о параметризованном типе доступна только на этапе компиляции и стирается в runtime.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое дженерики?', 1);

INSERT INTO answers_core2 (answer) VALUES (
'Они нужны для строгой типизации и проверки на этапе компиляции.
 Дженерики позволяют передавать тип объекта компилятору в форме <тип>.
 А компилятор уже может выполнить проверку типов во время компиляции. Также обеспечивается безопасность
 по приведению типов во время выполнения программы, т.е. строгая тип-я.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Для чего нужны дженерики?', 2);

INSERT INTO answers_core2 (answer) VALUES (
'Когда мы ничего не указываем в фигурных скобках, это и есть сырой тип ( List list = new ArrayList<>() ).
 Нужны для поддержания старого кода (обратная совместимость).
 Они использовались как раз до появления дженериков.
 И если их не указать, то под капотом используется Object.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое сырые типы (raw type)?', 3);

INSERT INTO answers_core2 (answer) VALUES (
'Wildcard - в переводе шальная карта, это когда мы можем использовать любой тип, ну или задать ограничения:
 “? extends T” - объект, который наследуется от Т, либо сам Т (обычно используется для получения в методе и
 называется Produsser, так как он отдает) – ковариантность.
 “? super T” - любой родитель Т, включая само Т (используется для отдачи в методе и называется Consumer,
 так как он только отдает)
 – контравариантность.
 А инвариантность,это когда мы не указываем ни Extends и не Super, а просто <?>.
 При использовании ? мы говорим компилятору, чтобы он игнорировал информацию о типе, т.е.
 <?> - это неограниченный символ подстановки.
 <?> означает то же что и <? extends Object>, т.е. принимает всё. // Это можно обойти, создав обобщенный метод,
 объявленный с переменной типа T.
 Короче, Дженерики не дают указывать наследников, если ты указал четкий тип, то он только этот указанный тип и
 будет пропускать, иначе вылетит эксепшен.
 Чтобы это сделать, нужно указать <?>, тогда мы сможем положить туда все что угодно.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое вайлдкарды?', 4);

INSERT INTO answers_core2 (answer) VALUES (
'Producer Extends Consumer Super. Wildcard здесь идет как подстановочный знак:
Если мы объявили wildcard с extends, то это producer. Он только «производит», предоставляет элемент из контейнера,
а сам ничего не принимает.
А если сделать wildcard с super — то это consumer. Он только принимает, но ничего не предоставляет.
Короче говоря:
Если мы только получаем объекты из дженерик-коллекции - это producer и надо использвовать extends.
Если мы только кладем объекты в коллекцию - это consumer и надо использовать super.
Если мы делаем и то и другое, то не надо использовать ни super, ни extends.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про принцип PECS.', 5);

INSERT INTO answers_core2 (answer) VALUES (
'Коллекция - это структура данных, или набор каких-либо объектов. Это как контейнер, который хранит в себе
объекты какого-то одного класса. Каждый из этих объектов в коллекции называется элементом.
У коллекций намного больше преимуществ чем у обычного массива, но только мы не можем ложить туда примитивы.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое Kоллекция?', 6);

INSERT INTO answers_core2 (answer) VALUES (
'Самый первый у нас идет интерфейс Iterable. От него наследуется интерфейс Collection.
Затем от Collection наследуются интерфейсы - List, Set, Queue.
От Listа имплементятся классы - ArrayList, LinkedList, и устаревшие Vector и Stack.
От Set идут - (классы) HashSet, LincedHashSet, TreeSet (При чем Трисет  сначала реализует интерфейс SortedSet).
От Queue идут - интерфейс Deque от которого идет класс ArrayDeque. И еще у нас в этих же ветках идет PriorityQueue.
Потом у нас стоит отдельно интерфейс Map.
От Мэпы идут две ветки:
В первой ветке идет HashMap и LinkedHashMap. И еще устаревший HashTable.
Во второй ветке идет интерфейс SortedMap, от которого идет Treemap.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про иерархию коллекций.', 7);

INSERT INTO answers_core2 (answer) VALUES (
'Коллекция (Например List и Set) это - совокупность каких-то элементов (обычно это экземпляры одного класса).
А Map - это уже совокупность пар: ключ-значение.
И еще у Map нет итерабл, не понятно по чему проводить итерацию.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Почему Map — это не Collection, в то время как List и Set являются Collection?', 8);

INSERT INTO answers_core2 (answer) VALUES (
'Collections это Класс. У Collections для того чтобы работать с коллекциями есть статические методы,
которые реализуют какие-то там алгоритмы (полиморфные) , а вот использование этих алгоритмов позволяет работать с
разными видами структур данных.
// Там еще есть методы: sort () - сортирует по порядку;
                        binarySearch () - деление напополам для быстрого поиска;
                        reverse () - сортировка по убыванию;
                        copy() - делает копирование;
Ну а Collection - это уже корневой интерфейс Java Collections Framework. Он, в основном применяется там,
где требуется высокий уровень абстракции, например, в классе Collections.
В общем, как я понял - у Collection более высокий уровень абстракции чем Collections.
// Методы для фильтра и сортировки в классе Collections.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('В чем разница между классами Collection и Collections?', 9);

INSERT INTO answers_core2 (answer) VALUES (
'Поведение с итераторами fail-safe не вызывает никаких исключений при изменении структуры коллекции,
потому что работает с её клоном.
// Пример: fail-safe - CopyOnWriteArrayList и итератор keySet коллекции ConcurrentHashMap.
Поведение с итераторами fail-fast, если коллекция меняется во время итерации, выбрасывает исключение
ConcurrentModificationException, но зато работает быстрее.
//Пример: fail-fast - Vector и Hashtable.
- fail-fast - являются итераторами по умолчанию.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какая разница между итераторами с fail-fast и fail-safe поведением?', 10);

INSERT INTO answers_core2 (answer) VALUES (
'Оба интерфейса предназначены для обхода коллекции.
Интерфейс Iterator - у него больше методов для работы с коллекциями и в какой-то версии Java (java-2) заменил
Enumeration(interface). Лучше юзать Iterator.
Различия:
с помощью Enumeration нельзя удалять элементы;
- А в Iterator можно, и к тому-же имена методов были исправлены на более читабельные.
//(Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует
Iterator.next() и т.д);
Enumeration считается устаревшим вместе с классами: Vector/Stack, тогда как Iterator есть во всех современных коллекциях.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Чем различаются Enumeration и Iterator?', 11);

INSERT INTO answers_core2 (answer) VALUES (
'Iterable интерфейс, Iterator тоже интерфейс, но они связаны между собой.
Интерфейс Iterable имеет метод - iterator(), а тип возвращаемого значения у него - (интерфейс) Iterator.
Объекты классов, которые реализуют интерфейс Iterable, могут использоваться в цикле foreach.
Короче, я проверял, вот этот метод iterator() - он аж оттуда с интерфейса Iterable потягивается в наши коллекции.
Мы можем у самого объекта коллекции вызвать метод iterator() и присвоить его объекту Iterator, затем с помощью
hasNext() и next() итерироваться по нашей коллекции, а с помощью remove() удалять их. Соответственно вот-этот for-each
использует этот итератор. Кстати, можно и в цикле while тоже использовать.
Цикл for-each можно использовать только при работе с коллекциями имплементирующих интерфейс Iterable.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Как между собой связаны Iterable, Iterator и «for-each»?', 12);

INSERT INTO answers_core2 (answer) VALUES (
'Можно, но только нужно использовать метод remove(). И это нужно делать после вызова метода next() от Iterator
Иначе при прохождении по ArrayList в цикле for сразу после удаления элемента вылетит
эксепшен - ConcurrentModificationException.
// При итерировании через обычный цикл, и если не использовать iterator, у меня выскакивал IndexOutOfBoundsException,
но цикл продолжает итерировать и программа не падает.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Можно ли итерируясь по ArrayList удалить элемент? Какое вылетит исключение?', 13);

INSERT INTO answers_core2 (answer) VALUES (
'Метод remove() удалит текущий элемент. Только есть один момент, сначала этот элемент необходимо получить с
помощью метода next(), если метод remove() вызвать до метода next(), то мы получим IllegalStateException.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Как поведёт себя коллекция, если вызвать iterator.remove()?', 14);

INSERT INTO answers_core2 (answer) VALUES (
'Set - имеет беспорядочное множество элементов и без дубликатов(по хешу работает), а List хранит в себе элементы
в том же порядке, в каком и были добавлены.
Потом - реализации Setа не добавляют своих новых методов, а используют только унаследованные от Collection.
Также в Sete разрешена только одна ссылка на Null, в отличие от Lista, где можно хранить сколько угодно Nullov.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Чем Set отличается от List?', 15);

INSERT INTO answers_core2 (answer) VALUES (
'Интерфейс Set расширяет интерфейс Collection.
Потом он не добавляет новых методов, ну, то есть имеет только методы унаследованные от Collection.
Set - набор уникальных элементов. Среди элем. может присутствовать null, но только один.
Имеет методы: add(), remove(), contans(), iterator().'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про интерфейс Set.', 16);

INSERT INTO answers_core2 (answer) VALUES (
'Класс HashSet - у него порядок добавления элементов будет непредсказуемым - для ускорения выборки элементов
используется хэширование.
Класс TreeSet - у него объекты сортируются по возрастанию, потому что применяется к/ч дерево.
Класс LinkedHashSet - он хранит элементы в порядке добавления. Вот как мы добавили, так они и будут извлекаться.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про реализации интерфейса Set.', 17);

INSERT INTO answers_core2 (answer) VALUES (
'HashSet работает быстрее, чем TreeSet, потому что у TreeSet много времени уходит на сортировку,
а у HashSeta по хешам выборка идет бысрее.
В HashSet элементы в случайном порядке, в TreeSet в отсортированном.
HashSet - он обеспечивает постоянную производительность - О(1) - для большинства операций, таких как add () ,
remove () и contains ().  А TreeSet логарифмическую -  log(n).'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('В чем отличия TreeSet и HashSet?', 18);

INSERT INTO answers_core2 (answer) VALUES (
'LinkedHashSet - он может сохранять порядок вставки элементов, а HashSet - не может.
В основе LinkedHashSet лежит LinkedHashMap.
Вот как раз благодаря этому - при обходе коллекции, порядок элементов - идентичен порядку добавления элементов.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Чем LinkedHashSet отличается от HashSet?', 19);

INSERT INTO answers_core2 (answer) VALUES (
'Ну также по возрастанию и будет. Он и так сортирует их по возрастанию.
Там хоть как в него элементы не добавляй он все равно их отсортирует по возрастанию, так как в основе TreeSet
лежит красно-черное дерево, которое умеет само себя балансировать и хранить элементы по возрастанию.
// Через Comparator можно поменять всю эту сортировку.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что будет, если добавлять элементы в TreeSet по возрастанию?', 20);

INSERT INTO answers_core2 (answer) VALUES (
'Все классы, которые реализуют интерфейс Set, они внутренне поддерживаются реализациями Map.
Значение, которые мы передаем в HashSet это те же ключи HashMap, только в качестве значения тут используются объекты.
Временная сложность основных операций у HashSet: На поиск, вставку и удаление:
Среднее О(1) , Худшее до Java 8: О(n)  , Худшее после Java 8: О(n Logarifm).'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Как устроен HashSet, сложность основных операций.', 21);

INSERT INTO answers_core2 (answer) VALUES (
'В основе LinkedHashSet лежит LinkedHashMap. Здесь тоже получается - порядок элементов при обходе коллекции
такой же как и порядок добавления элементов.
Временная сложность LinkedHashSet: На поиск, вставку и удаление:
Среднее О(1) , Худшее до Java 8: О(n)  , Худшее после Java 8: О(n Logarifm).'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Как устроен LinkedHashSet, сложность основных операций.', 22);

INSERT INTO answers_core2 (answer) VALUES (
'Время для базовых операций - логарифмическое.
Порядок элементов гарантируется, потому-что, в его основе лежит красно-черное дерево, оно умеет само себя балансировать,
что как раз и влияет на производительность. Потом у него есть дополнительные методы для упорядоченного списка:
first(), last(), headSet(), tailSet().
У него для всех операций идет логарифмическое время, т.е. О(n Logarifm).'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Как устроен TreeSet, сложность основных операций.', 23);

INSERT INTO answers_core2 (answer) VALUES (
'List хранит элементы в порядке добавления. Также у него есть несколько методов. Они обеспечивают вставку и
удаление элементов в середину списка.
Например метод add() перегружен, можно вставлять элементы как в конец, так и по индексу.
remove() - удалять тоже можно по индексу.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про интерфейс List.', 24);

INSERT INTO answers_core2 (answer) VALUES (
'ArrayList реализован внутри как обычный массив. Поэтому при вставке элемента в середину,
приходится сначала сдвигать все элементы, которые после него, на одну ячейку в право, а уже затем в освободившееся
место вставляется новый элемент.
У него там внутри есть автоматический механизм расширения, а вот автоматического «сжатия» нет, но зато его можно
выполнить явно, с помощью метода trimToSize() (там было так написано, но что-то я такого метода не видел).
Временная сложность базовых операций у ArrayList: На поиск, вставку и удаление: Среднее О(n) , Худшее О(n).
Метод get(index) O(1).'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Как устроен ArrayList? Cложность основных операций.', 25);

INSERT INTO answers_core2 (answer) VALUES (
'Двухсвязный список. Он состоит из элементов одного типа, которые хранят данные и хранят ссылки на следующий и
предыдущий элементы.
Временная сложность: для поиска, добавления и удаления из середины списка - O(1) константное [потому что выполняется
одна единственная команда для его обнаружения];
А вот на вставку и удаление из середины списка, или получение элемента по индексу уже нужно линейное время O(n)
[Например, когда процедура, суммирует все элементы списка, и требует время, которое пропорционально длине списка].
Позволяет добавлять любые значения, в том числе и null. Для хранения примитивных типов - используются классы-оберки;'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Как устроен LinkedList? Cложность основных операций.', 26);

INSERT INTO answers_core2 (answer) VALUES (
'Потому что благодаря этому можно создать двухнаправленную очередь из любых элементов (в том числе и null).
Каждый объект, который помещен в этот двусвязанный список, является нодом (узлом). А в каждом узле содержится элемент,
и ссылка на предыдущий и следующий узел. Получается двусвязный список (ну или просто связный) состоит из
последовательности узлов, каждый из них предназначен для хранения объекта, тип которого был параметризован еще раннее.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Почему LinkedList реализует и List, и Deque?', 27);

INSERT INTO answers_core2 (answer) VALUES (
'ArrayList это список, реализованный на основе массива, а LinkedList — это двусвязный список, состоящий из нод (из узлов).
Потом LinkedList работает медленнее ArrayListа и потребляет больше памяти. Его лучше применять для вставки/удаления
элементов куда-то в середину, или когда нужно гарантированное время добавления элемента в список.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Чем отличаются ArrayList и LinkedList?', 28);

INSERT INTO answers_core2 (answer) VALUES (
'Queue - переводится как \"очередь\", элементы хранятся в таком порядке, чтобы их было удобнее обработать.
Элементы добавляются по принципу FIFO (first-in-first-out) порядке. //Есть своя реализация - PriorityQueue.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое Queue?', 29);

INSERT INTO answers_core2 (answer) VALUES (
'Deque - это двухстороняя очередь, расширяет queue. Он отличается от Queue тем, что можно добавлять и удалять
элементы как в хвосте так и в голове.
Методов у него больше чем в Queue. Например:
addFirst(E e);
addLast(E e);
И кстати Deque может работать как по принципу FIFO, так и по LIFO.
В Deque, и Queue обычно методы equals() и hashCode() не переопределяются. // а используются методы класса Object,
которые сравнивают ссылки.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое Dequeue? Чем отличается от Queue?', 30);

INSERT INTO answers_core2 (answer) VALUES (
'Его реализуют классы: LinkedList,  ArrayDeque.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Приведите пример реализации Dequeue.', 31);

INSERT INTO answers_core2 (answer) VALUES (
'Интерфейс Queue, и все кто под ним находится.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какая коллекция реализует  FIFO?', 32);

INSERT INTO answers_core2 (answer) VALUES (
'Там идут классы: ArrayDeque и Vector'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какая коллекция реализует  LIFO?', 33);

INSERT INTO answers_core2 (answer) VALUES (
'Для x32 систем:
Каждый элемент LinkedList хранит ссылки:
на предыдущий элемент - 4 байта,
следующий элемент - 4 байта,
и ссылку на данные - 4 байта.
Сам объект типа Node (заголовок) занимает приблизительно 8 байт.
Размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. (Округляем до 24)
Примитив типа byte занимает 1 байт памяти, но в списке примитивы упаковываются:
объект типа Byte занимает в памяти 16 байт (8 байт на заголовок объекта, 1 байт на поле типа byte и 7 байт для кратности 8).
Также напомню, что значения от -128 до 127 кэшируются и для них новые объекты каждый раз не создаются.
Таким образом, в x32 JVM 24 байта тратятся на хранение одного элемента в списке
и 16 байт - на хранение упакованного объекта типа Byte.
Для 64-битной JVM каждая ссылка занимает 8 байт, размер заголовка каждого объекта составляет 16 байт (два машинных слова).
Вычисления аналогичны.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Оцените количество памяти на хранение одного примитива типа byte в LinkedList?', 34);

INSERT INTO answers_core2 (answer) VALUES (
'ArrayList основан на массиве, для примитивных типов данных сначала идет автоматическая упаковка значения,
поэтому 16 байт тратится на хранение упакованного объекта и 4 байта (8 для x64) - на хранение ссылки на объект
в самой структуре данных. Получается, в x32 JVM 4 байта используются на хранение одного элемента и 16 байт - на хранение
упакованного объекта типа Byte. Для x64 - 8 байт и 24 байта соотвтетсвенно.  х32=20байт х64=32байт.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Оцените количество памяти на хранение одного примитива типа byte в ArrayList?', 35);

INSERT INTO answers_core2 (answer) VALUES (
'Map реализуют классы: TreeMap, HashMap, LinkedHashMap, HashTable.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какие существуют реализации Map?', 36);

INSERT INTO answers_core2 (answer) VALUES (
'HashMap это обычный массив (а если точнее - ассоциативный массив), каждая ячейка, у этого массива, это бакет.
Изначальный размер массива - 16 бакетов.
В каждом бакете хранится либо связанный список, либо, если в одном из бакетов становится болше 8-ми элементов,
он (список) может перерождаться в к/ч дерево. Перед тем как положить элемент в корзину, сначала с помощью хеш-кода
ключа вычисляется номер самой корзины. Затем, если корзина пустая - элемент сразу кладется в эту корзину,
а если не пустая, то происходит прохождение по списку элементов и сравнивание нового элемента (который мы хотим
положить в корзину) с каждым элементом в списке. Если хешкоды сравниваемых элементов одинаковые, идет сравнение по
методу equalas().
Вот этот массив (его еще называют Entry[]), хранит в себе ссылки на вот эти списки. //(цепочки) значений.
Каждая нода в этом списке, она представляет из себя Ключ-значение и адрес к следующей ноде.
Но если следующая нода отсутствует, то адрес будет равен Null.
Ключи и значения могут быть любых типов, в том числе и null. Потом, если мы хотим добавить в мапу Null,
то он пойдет в самый первый бакет.
Затем, у нас есть hashFunction() - она принимает hashCode ключа, а возвращает номер корзины.
Потом, когда мы уже определились с корзиной, перед тем как положить элемент в эту корзину,
сравнивается - сначала хешкод ноды, и также возможна проверка на equalas().
Если и хэшкод и equalas равны: идет перезапись.
Если equals не равен: то элемент добавляется в конец списка Hashmap. Также
HashMap имеет поле loadFactor. Оно может быть задано через конструктор. По умолчанию - 0.75.
Его произведение на количество корзин - даст нам необходимое число объектов которое нужно добавить, чтобы состоялось
удвоение количества корзин.
Например если у нас мапка с 16-ю(default) корзинами, а loadFactor равняется 0.75, то удвоение корзин произойдет тогда,
когда мы добавим 16 * 0.75 = 12 объектов.
После удвоения - все объекты будут перераспределены, с учетом нового количества корзин.
Потом я еще не рассказал: когда у нас количество нод зашкаливает 8, или корзины становятся равными 64, то наш список
перерождается в к/ч дерево.
Временная сложность основных операций у HashMap: На поиск, вставку и удаление:
Среднее О(1) , Худшее (До Java-8) О(n) , Худшее (После Java-8) О(n логарифм).'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Как устроена HashMap, сложность основных операций? (Расскажите про принцип корзин).', 37);

INSERT INTO answers_core2 (answer) VALUES (
'LinkedHashMap  - упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, вот как добавили элементы,
в таком же порядке будем извлекать.
Это достигается благодаря двунаправленным связям между элементами (также как в LinkedList).
Но это преимущество имеет также и недостаток. Недостаток — это увеличение памяти, которое занимет коллекция.
Благодаря тому что основную работу на себя берет родительский класс, серьезных отличий в реализации HashMap и
LinkedHashMap не так уж и много.
Временная сложность основных операций у LinkedHashMap такая же как и у HashMap.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое LinkedHashMap?', 38);

INSERT INTO answers_core2 (answer) VALUES (
'Класс TreeMap<K, V> реализован на основе к/ч дерева. Наследуется от класса AbstractMap, реализует интерфейсы
NavigableMap и SortedMap. Все объекты в TreeMap сортируются по возрастанию их ключей, все происходит автоматически.
(Не так как HashMap, где все идет беспорядочно).
Временная сложность основных операций у TreeMap - логарифмическая.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Как устроена TreeMap, сложность основных операций?', 39);

INSERT INTO answers_core2 (answer) VALUES (
'Он находится в Мэпе. Реализует интерфейс Map, на основе хеш-таблиц. Ключи у него - это объекты WeakReference-класса.
Я так понимаю ключи сделаны как слабые ссылки. И - если не существует ни одной ссылки, указывающей на этот ключ,
то запись в WeakHashMap будет автоматически удалена. // Примененяется WeakHashMap в реализации обычного кэша.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое WeakHashMap?', 40);

INSERT INTO answers_core2 (answer) VALUES (
'Сначала (по значению hashCode()) вычисляется индекс ячейки массива. Затем в список этой ячейки будет
добавлен элемент. Перед тем как добавить, сначала выполнится проверка, ну т.е. - есть ли элементы в этой ячейке или нет.
Если элементы с таким hashCode() уже присутствует, но их equals() методы не равны, то элемент будет добавлен в конец списка.
А если вдруг и по equals() тоже равны, то элемент перезаписывается.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), для которых equals() == false?', 41);

INSERT INTO answers_core2 (answer) VALUES (
'В таком случае - объект скорее всего добавится, но обратно мы не сможем его получить.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что будет, если мы кладем в HashMap ключ, у которого equals и hashCode определены некорректно?', 42);

INSERT INTO answers_core2 (answer) VALUES (
'Да, возможно. Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()?', 43);

INSERT INTO answers_core2 (answer) VALUES (
'Потому что в этом нет никакого смысла. Ну во первых - метод вычисления хэш-кода массива не переопределен и
вычисляется по стандартному методу hashCode() из Objecta. Потом - метод equalas() - тоже не переопределен.
И из-за этого мы не сможем отыскать наш элемент. я так понял.
// И еще, потому что - хэш-код массива не зависит от хранимых в нем элементов и вычисление идет по его ссылке.
А ссылка маленькая, мы там все равно большую комбинацию Хеша не сможем получить, например как в String.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Почему нельзя использовать byte[] в качестве ключа в HashMap?', 44);

INSERT INTO answers_core2 (answer) VALUES (
'Да, будет, но тогда в одну корзину будет все попадать. Потому что HashMap потом вырождается в связный список,
и теряет все свои преимущества.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?', 45);

INSERT INTO answers_core2 (answer) VALUES (
'O(N). Худший случай - это поиск ключа в таблице со списками,
а там - перебор ключей занимает линейное время.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какое худшее время работы метода get(key) для ключа, которого нет в HashMap?', 46);

INSERT INTO answers_core2 (answer) VALUES (
'O(N) - линейное.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какое худшее время работы метода get(key) для ключа, который есть в HashMap?', 47);

INSERT INTO answers_core2 (answer) VALUES (
'Это интерфейс, который содержит только 1 абстрактный метод.
Может включать сколько угодно default (и static) методов и при этом он остается функциональным.
//потому что default методы - не абстрактные.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое функциональный интерфейс?', 48);

INSERT INTO answers_core2 (answer) VALUES (
'Чтобы точно определить интерфейс что он - функциональный. Она не даст определить второй абстрактный метод в интерфейсе.
(Хотя можно и без нее).'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Для чего нужна аннотация @FunctionalInterface?', 49);

INSERT INTO answers_core2 (answer) VALUES (
'Predicate<T> - имеется функция, которая получает на вход экземпляр класса T и возвращает на выходе
значение типа boolean.
Supplier<T> - есть функция, которая ничего не принимает на вход, и на выходе возвращающает результат класса T.
Consumer<T> - имеется функция, которая получает на вход экземпляр класса T, производит с ним какое-то действие
и ничего не возвращает.
Function<T,R> - имеется функция, получает на вход экземпляр класса T и возвращает на выходе экземпляр класса R.
UnaryOperator<T> - принимает в параметры объект типа T, выполняет с ним какую-то операцию и возвращает результат этой
операций - объект типа T
BinaryOperator<T, Т> - там реализуется функция, она получает на вход - два экземпляра типа T и на выходе
возвращающает - экземпляр класса T.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какие встроенные функциональные интерфейсы вы знаете?', 50);

INSERT INTO answers_core2 (answer) VALUES (
'Ссылка на метод (это квадраточие) - это сокращенный синтаксис лямбда - выражения, который выполняет только один метод.
Это позволяет нам ссылаться на конструкторы или методы, в каком-то определенном классе.
Например: Consumer<String> consumer = str -> System.out.println(str);
можно переписать по другому, с помощью ссылки на метод: Consumer<String> consumer = System.out::println;
Я так понимаю - вот бывает же - когда мы можем написать и большую лямбда функцию,
то тогда лучше использовать ссылку на метод.
Бывают:
Ссылки на статические методы.
Ссылки на нестатические методы (конкретного объекта)
Ссылки на конструкторы - (например: Имя класса::new)'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое ссылка на метод?', 51);

INSERT INTO answers_core2 (answer) VALUES (
'Лямбда-выражение - упрощённая запись анонимного класса, которая как раз может реализовывать функциональный интерфейс.
Ее можно заменить, как говорилось выше - ссылкой на метод.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое лямбда-выражение? Чем его можно заменить?', 52);

INSERT INTO answers_core2 (answer) VALUES (
'Stream (интерфейс) - это когда идет последовательность элементов, над которой можно производить различные операции.
Операции над стримами бывают или промежуточными или терминальными. Терминальные операции возвращают результат
определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом - можно строить цепочки из
нескольких операций над одним и тем же стримом. Задача стрима, значит.. - упростить работу с наборами данных,
ну.. например - выполняя какие-то операции фильтрации, сортировки, ну.. и другие манипуляции с данными.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое Stream API? Для чего нужны стримы?', 53);

INSERT INTO answers_core2 (answer) VALUES (
'Потому что - методы промежуточных операций не будут выполняться, до тех пор - пока не будет вызван терминальный метод.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Почему Stream называют ленивым?', 54);

INSERT INTO answers_core2 (answer) VALUES (
'Стрим из указанных элементов: Stream.of(\"\"1\"\", \"\"2\"\", \"\"3\"\") ,
Стрим из коллекций. Например: List: list.stream() ,
Стрим из Map: map.entrySet().stream().
Стрим из массива: Arrays.stream(array)
используется,
Можно сделать из файла - при помощи методов Files.list() и Files.walk()
Можно получить стрим из строки - методом chars().
Можно также получить стрим с помощью Итерарации какой-то функции
Можно получить стрим из диапазона каких-то чисел.
Можно также получить стрим - конкатенацией других стримов.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какие существуют способы создания стрима?', 55);

INSERT INTO answers_core2 (answer) VALUES (
'Ну, сначала мы создаем саму коллекцию.
//Например: Collection<String> collection = Arrays.asList(\"\"a1\"\", \"\"a2\"\", \"\"a3\"\");
Затем у этой коллекции вызываем метод stream().
//Stream<String> streamFromCollection = collection.stream(); Я так понимаю - нужно вызвать метод stream() у коллекции.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Как из коллекции создать стрим?', 56);

INSERT INTO answers_core2 (answer) VALUES (
'filter(boolean - Predicate) ,
map() ,
flatMap() ,
limit(n) ,
skip(n) ,
concat(Stream s1, Stream s2) ,
peek(someFunction) ,
distinct() ,
sorted().'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какие промежуточные методы в стримах вы знаете?', 57);

INSERT INTO answers_core2 (answer) VALUES (
'Этот метод существует в основном, для отладки кода, когда мы хотим видеть, как элементы проходят через
определенную точку в нашем стриме.
// peek (принимает Consumer). // Например: integerStream.peek(System.out::println).'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про метод peak().', 58);

INSERT INTO answers_core2 (answer) VALUES (
'Метод map() делает маппинг, т.е. – преобразование из одного в другое. То есть преобразует объект какого-то
типа в объект какого-то другого типа.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про метод map().', 59);

INSERT INTO answers_core2 (answer) VALUES (
'flatMap выполняется тогда, когда из одного элемента нужно получить несколько.
Например:
Stream.of(\"H e l l o\", \"w o r l d !\")
.flatMap((p) -> Arrays.stream(p.split(\" \")))
.toArray(String[]::new);
Результат: [\"H\", \"e\", \"l\", \"l\", \"o\", \"w\", \"o\", \"r\", \"l\", \"d\", \"!\"]'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про метод flatMap().', 60);

INSERT INTO answers_core2 (answer) VALUES (
'map - он преобразует один тип в другой, и для каждого объекта в стриме возвращает по 1 объекту.
flatMap - делает из одного элемента - несколько элементов.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Чем отличаются методы map() и flatMap().', 61);

INSERT INTO answers_core2 (answer) VALUES (
'Фильтрует стрим, возвращает только те элементы, которые проходят по критерию (Predicate).
Проверяет значение на “true” и “false”.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про метод filter()', 62);

INSERT INTO answers_core2 (answer) VALUES (
'limit(n) - ограничивает наш стрим, сколько мы указали - столько и пройдет дальше по конвееру.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про метод limit()', 63);

INSERT INTO answers_core2 (answer) VALUES (
'skip(n) - пропускает первые элементы. То есть, мы можем указать - сколько элементов можно пропустить.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про метод skip()', 64);

INSERT INTO answers_core2 (answer) VALUES (
'sorted() - сортирует, т.е. возвращает отсортированный поток.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про метод sorted()', 65);

INSERT INTO answers_core2 (answer) VALUES (
'distinct() - обрабатывает стрим и возвращает его уже без дубликатов. Короче он отсеивает дубликаты.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про метод distinct()', 66);

INSERT INTO answers_core2 (answer) VALUES (
'forEach – принимает consumer, получается он этот стрим возвращает в переданный нами консьюмер (который потребитель).
forEachOrdered – как и forEach, но только он еще и упорядочивает элементы.
count() - подсчитывает все значения
max() - возвращает максимальный элемент
min() - возвращает минимальный элемент
findAny() - как я понял, находит какой-то любой элемент.
anyMatch() - проверяет на наличие совпадения ,
т.е. совпадают наши элементы или нет.
allMatch() – (принимает предикат) проверяет - все ли элементы нашего стрима проходят по определенному условию.
Возвращает boolean.
findFirst – возвращает первый элемент из стрима.
collect – собирает все элементы в одну коллекцию, которую мы можем указать.
reduce – он там как-то сортирует, применяет бинарный оператор к каждой паре элементов стрима, до тех пор - пока
не останется один элемент.
toArray  - возвращет массив.
Потом - все терминальные методы возвращают Optional - чтобы предостеречься от NPE.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какие терминальные методы в стримах вы знаете?', 67);

INSERT INTO answers_core2 (answer) VALUES (
'collect () - это один из терминальных методов.
Преобразует стрим в коллекцию.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про метод collect()', 68);

INSERT INTO answers_core2 (answer) VALUES (
'Возвращает какой-то один результат. (от слова \"уменьшить\")
Использует бинарный оператор к каждой паре элементов стрима, пока не останется один элемент.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про метод reduce()', 69);

INSERT INTO answers_core2 (answer) VALUES (
'С помощью него мы можем упаковывать стримы в коллекции:
toList() - преобразует стрим в список — List<T>
toSet() - преобразует стрим в список — Set<T>
toMap() - преобразует стрим в список — Map<K, V>
Используются в методе collect().'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про класс Collectors и его методы.', 70);

INSERT INTO answers_core2 (answer) VALUES (
'Для того чтобы сделать (обычный) последовательный поток параллельным, надо вызвать у объекта Stream метод parallel().
Также можно использовать parallelStream() (из интерфейса Collection), чтобы создать параллельный поток из коллекции.
Проблема только в том, что он блокирует основной поток.
//Потом, есть такой метод Sequal(), который обратно сливает несколько потоков в один.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите о параллельной обработке в Java 8.', 71);

INSERT INTO answers_core2 (answer) VALUES (
'Из примитивов, в Java 8 нельзя создавать Streamы напрямую. Но чтобы их все-таки использовать,
есть 3 вида Stream-а: IntStream, LongStream, DoubleStream. Они работает быстрее, чем стрим с классами-обертками.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое IntStream и DoubleStream?', 72);

INSERT INTO answers_core2 (answer) VALUES (
'Поддержка лямбда-вражений.
Ссылки на методы ::
Функциональные интерфейсы. default методы в интефейсах.
Новое api для работы с датами. Nashorn движок JavaScript (разрабатываемый полностью на Java компанией Oracle).
Кодировщик/декодировщик Base 64.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какие нововведения появились в java 8?', 73);

INSERT INTO answers_core2 (answer) VALUES (
'LocalDate , LocalTime, LocalDateTime, ZonedDateTime, Period. Эти классы, как я понял - автоматически привязываются
к локальному часовому поясу.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какие новые классы для работы с датами появились в java 8?', 74);

INSERT INTO answers_core2 (answer) VALUES (
'Optional - такой интересный класс, он позволяет безопасно использовать ссылки на null.
Благодаря ему проверки на null можно не делать, и можно не бояться NullPointerException.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Расскажите про класс Optional', 75);

INSERT INTO answers_core2 (answer) VALUES (
'Nashorn, какой-то там движок для javascript. Nashorn — немецкое слово (Носорог).'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое Nashorn?', 76);

INSERT INTO answers_core2 (answer) VALUES (
'Это такой инструмент, используется в командной строке, для выполнения кода JavaScript в консоли.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое jjs?', 77);

INSERT INTO answers_core2 (answer) VALUES (
'Base64.Encoder и Base64.Decoder'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какой класс появился в Java 8 для кодирования/декодирования данных?', 78);

INSERT INTO answers_core2 (answer) VALUES (
'Вызвать метод getEncoder() класса Base64.
- Вызвать метод getDecoder() класса Base64.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Как создать Base64 кодировщик и декодировщик?', 79);

INSERT INTO answers_core2 (answer) VALUES (
'putIfAbsent() - метод добавляет пару «ключ-значение», если этого ключа там не было;
forEach() - принимает функцию, которая производит операцию над каждым элементом.
compute() создаёт или обновляет текущее значение.
computeIfPresent() - обновляет значение, если ключ существует.
getOrDefault() - возвращает переданное ему значение (по умолчанию), если ключ отсутствует.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?', 80);

INSERT INTO answers_core2 (answer) VALUES (
'LocalDateTime - это объединение LocaleDate и LocalTime, он содержит одновременно и дату и время.
У него есть методы: plusMinutes, plusHours, toSecondOfDay и т.д.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое LocalDateTime?', 81);

INSERT INTO answers_core2 (answer) VALUES (
'java.time.ZonedDateTime — аналог java.util.Calendar, короче класс-календарь.'
);
INSERT INTO questions_core2 (question, answer_id) VALUES ('Что такое ZonedDateTime?', 82);


-- src/main/resources/db/db.db.migration/V3__insert_multithreading.sql
-- MULTITHREADING
INSERT INTO answers_mt (answer) VALUES (
'Процесс — это экземпляр программы во время ее выполнения, т.е. независимый объект, которому выделены
 системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве.
 Один процесс не может получить доступ к данным другого процесса.
 И если процессу нужно получить доступ к ресурсам другого процесса, то ему надо организовать межпроцессное взаимодействие.
 Это могут быть: файлы, конвейеры, каналы связи между компьютерами и.т.д.
 Операционная система - она отвечает за разграничение физической памяти для каждого процесса.
 И создает для него «виртуальное адресное пространство».
 Процесс делится на потоки. В рамках одного процесса может находиться один или несколько потоков,
 которые существуют в пределах границ одного процесса.
 - Поток(thread) — это одна из частей выполнения процесса. И в каждом потоке код выполняется последовательно.
 Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными. Также потоки расходуют меньше
 ресурсов чем процессы, и поэтому намного выгоднее создавать дополнительные потоки, чем дополнительные процессы.
 И еще: поток это - объект, реализующий интерфейс Runnable.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Чем процесс отличается от потока?', 1);

INSERT INTO answers_mt (answer) VALUES (
'Thread - это класс, с помощью которого можно создать поток.
 Runnable - это интерфейс, который имеет более высокий уровень абстракции чем Thread.
 В чем разница:
 В классе Thread имеется несколько методов. Из них, в классе-наследнике, переопределять обязательно,
 нужно только метод run().
 Точно такой же метод run() есть и в интерфейсе Runnable. (Он там единственный). Потому что Thread сам как раз
 имплементирует Runnable (я проверял).
 Создавать класс унаследованный от класса Thread, рекомендуется только в том случае, если надо дополнить его
 какими-то своими методами.
 А если никакие методы из класса Thread переопределять не нужно, то тогда лучше использовать интерфейс Runnable.
 // В Runnable самая простая реализация.
 // Тем более, реализация интерфейса Runnable позволяет создаваемому потоку наследовать любой другой класс,
 т.е не обязательно Thread использовать.
 Также Runnable решает проблему множественного наследования.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Чем Thread отличается от Runnable? Когда нужно использовать Thread, а когда Runnable?', 2);

INSERT INTO answers_mt (answer) VALUES (
'Монитор - это механизм (или сущность, котрая живет в каждом объекте) для синхронизации потоков,
 он обеспечивает доступ к ресурсам в каждом объекте.
 Монитор встроен в класс Object и имеется у каждого объекта.
 В Java - монитор активируется с помощью ключевого слова synchronized.
 У каждого монитора есть некий - mutex. Мьютекс — это специальный объект для синхронизации потоков.
 Mutex - это как id захватившего его объекта. Если этот id равен 0 – ресурс свободен.
 Если не равен 0 – значит ресурс занят. // Это как замок.
 Т. е. когда мьютекс монитора занят каким-то потоком, все остальные потоки стоят в очереди и ждут пока он станет свободным.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что такое монитор? Как монитор реализован в java?', 3);

INSERT INTO answers_mt (answer) VALUES (
'Синхронизация это механизм, который позволяет выполнять потоки параллельно.
 В Java все объекты имеют блокировку, т.е. который обеспечивается монитором.
 И благодаря этой блокировке(монитору) - только один поток может одновременно  получить доступ к коду объекта.
 Такая синхронизация, во первых не дает повредить сам объект, во вторых благодаря ей - потоки не могут пользоваться объектом одновременно.
 Способы синхронизации в Java:
 -- С использованием wait() и notify().
 Это когда мы используем ключевое слово sinchronyzed или sinchronyzed-блоки. И внутри (метода или синхр-блока)
 прописываем методы wait() и notify().
 Получается - поток захватывает монитор объекта, выполняет какие-то действия с объектом, и при определенных условиях
 вызывает у этого объекта метод wait().
 После вызова wait() - монитор освобождается, а этот поток ждет, пока где-то, какой-нибудь другой поток,
 не вызовет метод notify().
 И после его вызова, первый ждущий на объекте поток «просыпается» и может продолжать свою работу.
 // Может и не продолжать. В зависимости от условий.
 Потом, методы wait() и notify() - они не синхронизированы. И поэтому захват монитора надо делать в явном виде,
 например в synchronized-блоке.
 -- С использованием join().
 join() - метод, который может быть вызван у объекта класса Thread.
 Он позволяет текущему потоку остановиться и подождать, пока другой поток, связанный с этим же объектом,
 не закончит свою работу.
 -- С использованием классов из пакета java.util.concurrent.Locks. Там тоже есть механизмы для синхронизации потоков,
 и это хорошая альтернатива базовым: synchronized, wait, notify, notifyAll.
 Там есть такие как: Интерфейс Lock с методами lock(), unlock(), tryLock(); (Это уже не системная синхронизация).'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что такое синхронизация? Какие способы синхронизации существуют в java?', 4);

INSERT INTO answers_mt (answer) VALUES (
'- wait(): приостанавливает поток, ждет пока другой поток не вызовет метод notify() или notifyAll();
 - notify(): продолжает работу потока, у которого еще раньше был вызван метод wait();
 - notifyAll(): продолжает работу всех потоков, у которых тоже раньше был вызван метод wait().
 Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running)
 в состояние Ожидания (Waiting).
 Метод notify() подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние
 Работоспособный (Runnable).
 Метод notifyAll() подаёт сигнал всем ожидающим потокам, чтобы они вернулись в состояние Работоспособный (Runnable).
 Если никто из потоков не находится в ожидании, т.е. не вызывали метод wait(), то при вызове notify() или
 notifyAll() ничего не происходит.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Как работают методы wait(), notify() и notifyAll()?', 5);

INSERT INTO answers_mt (answer) VALUES (
'- New (Новый) - объект класса создан в потоке, но еще не запущен. Он пока что только создан и еще
 не выполняется.
 - Runnable (Работоспособный) - поток готов к выполнению, но планировщик его еще не выбрал.
 - Running (Запущенный) – поток выполняется.
 - Waiting, blocked или sleeping (Ожидающий) - поток блокирован, либо поток ждет окончания работы другого потока.
 Либо спит).
 - Dead (Остановленный) - поток умер, т.е завершен (run())//Если поток завершен, а мы вызываем метод start()
 (для dead потока), то будет выброшено исключение.
 У класса Thread есть внутренний класс-перечисление State (состояние), а также метод getState().
 public enum State {}
 NEW, — поток создан, но еще не запущен;
 RUNNABLE, — поток в рабочем состоянии;
 BLOCKED, — поток блокирован;
 WAITING, — поток ждет окончания работы другого потока;
 TIMED_WAITING, — поток ждет окончания другого потока, некоторое время;
 TERMINATED; — поток завершен.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('В каких состояниях может находиться поток?', 6);

INSERT INTO answers_mt (answer) VALUES (
'Semaphore – это тоже синхронизатор, только со счётчиком. Изначальное значение счетчика задается в конструкторе.
 Когда поток заходит в заданный блок кода, то значение счетчика уменьшается на единицу, когда поток его покидает, то увеличивается.
 Если значение счетчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защенного блока.
 Т.е. семафор - он ограничивает доступ к объекту какому-то определенному числу потоков.
 Например к одному ресурсу могут обращаться не больше 5-ти потоков.
 // Для получения разрешения у семафора надо вызвать метод acquire().
 // Semaphore - используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве.
 Например: подключение к базе данных в пуле.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что такое семафор? Как он реализован в Java?', 7);

INSERT INTO answers_mt (answer) VALUES (
'Volatile - это модификатор. Он отключает кэширование переменной, чтобы эту переменную могли использовать
 все потоки. Т.е. делает ее общей.
 // Потом, переменная с ключевым словом: volatile - находится в хипе, а не в кэше стека.
 Переменная volatile является атомарной только для чтения. Но если происходит какая-то другая операция, например:
 инкримент, то атомарности уже не будет.
 Потому что сначала выполняется чтение(1), потом изменение(2), а затем запись(3).
 Такая операция не является атомарной, потому что, где-то по середине, (между операциями) в неё может вклиниться
 другой поток.
 А атомарная операция - это операция которая выполняется только за ОДИН ШАГ.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что обозначает ключевое слово volatile? Почему операции над volatile переменными не атомарны?', 8);

INSERT INTO answers_mt (answer) VALUES (
'Вот volatile ведь не гарантирует атомарность.
 А вот например - class AtomicInteger - предоставляет атомарные методы, чтобы можно было выполнять нескольких операций - атомарно.
 Метод: getAndIncrement() – его можно использовать вместо оператора инкремента,
 // Чтобы увеличивать значение переменной - атомарно.
 Также, кроме AtomicInteger - есть похожие классы, но уже для других типов данных.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Для чего нужны Atomic типы данных? Чем отличаются от volatile?', 9);

INSERT INTO answers_mt (answer) VALUES (
'Потоки-демоны - это потоки для обслуживания основных потоков (приложения) в фоновом режиме.
 Запускаются они с помощью метода setDaemon(boolean value), и вызываются у обычного потока перед его запуском.
 Как только выполнится основной поток (метод main()) - выполнение потока-демона тоже завершается, даже если поток-демон
 еще работает.
 А обычные потоки не могут принудительно остановить поток-демон.
 Метод isDaemon() позволяет определить, является ли указанный поток демоном или нет.
 Бывает так что когда программа заканчивается, а поток-демон все еще продолжает работать. // Поэтому он и Демон.
 Примером для потока-демона является сбор мусора.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что такое потоки демоны? Для чего они нужны? Как создать поток-демон?', 10);

INSERT INTO answers_mt (answer) VALUES (
'Приоритеты потоков - их устанавливает планировщик потоков. Он решает, когда и какому потоку можно работать.
 (и ставит их в очередь).
 Значит, в чем разница: Потоки с высоким приоритетом - они получают больше процессорного времени,
 чем потоки с низким приоритетом.
 // Но не всегда. Там бывают еще и другие критерии: например - является ли поток демоном или нет.
 А у демона - самый низкий приоритет.
 Для установки приоритета (у потока) вызывается метод setPriority(int level).
 Значение level можно указывать от MIN_PRIORITY = 1 до MAX_PRIORITY = 10.
 По умолчанию стоит - NORM_PRlORITY = 5.
 Чтобы узнать, какой приоритет у потока, можно вызвать метод: getPriority().
 Также можно выполнить любой поток принудительно, т.е. не взирая на приоритет, с помощью метода yield().
 // Метод yield() - уступает место другому потоку.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что такое приоритет потока? На что он влияет? Какой приоритет у потоков по умолчанию?', 11);

INSERT INTO answers_mt (answer) VALUES (
'Метод join(), позволяет дожидаться, пока тот поток, к которому он присоединен, не завершит свою работу.
 Либо пока этот поток не отработает время переданное в параметры метода join(long millis) - а там время указывается
 в миллисекундах.
 Это может использоваться, например: Когда мы, сначала распараллелили все потоки, а потом, чтобы снова слить их
 всех в кучу - надо дождаться результатов вычисления всех остальных потоков.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Как работает Thread.join()? Для чего он нужен?', 12);

INSERT INTO answers_mt (answer) VALUES (
'Метод yield() - он возвращает выполняющийся поток в состоянии runnable (работоспособный),
 для того чтобы уступить место другому потоку.
 Метод - sleep () - приостанавливает выполнение потока на указанное время, в параметрах метода.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Чем отличаются методы yield () и sleep()?', 13);

INSERT INTO answers_mt (answer) VALUES (
'Метод stop() - останавливает поток, но слишком грубо, потому что не дожидается других потоков.
 Он не является потокобезопасным. И он Deprecated.
 - Метод interrupt() - более безопасен чем stop(). Но работает по другому: Через метод interrupt() мы просто посылаем
 сигнал потоку, что хотим его прервать.
 А если этот сигнал будет проигнорирован, то поток может и не остановится. Потом метод - interrupt() устанавливает
 статус прерывания(прервался поток или нет).
 А у метода interrupted(), как я понял все то же самое, только статус прерывания, при вызове, сбрасывается.
 - Метод isInterrupted() - он проверят статус: прервался ли поток или нет. // Но при этом он вызывается из другого потока.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Как правильно остановить поток?
                "Для чего нужны методы .stop(), .interrupt(), .interrupted(), .isInterrupted().', 14);

INSERT INTO answers_mt (answer) VALUES (
'Интерфейс Runnable появился раньше чем Callable (Callable находится в библиотеке java.util.concurrent).
 Классы, реализующие интерфейс Runnable, чтобы выполнить свои задачи должны реализовывать метод run().
 Классы, реализующие интерфейс Callable - метод call();
 Метод run() не возвращает никакого значения. Он void.
 А метод call() возвращает дженерик, т.е. то что в него параметризовали (потому что Callable - это параметризованный
 функциональный интерфейс).
 Также метод run() НЕ может выбрасывать исключения, а метод call() может.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Чем Runnable отличается от Callable?', 15);

INSERT INTO answers_mt (answer) VALUES (
'Этот класс, который используется для асинхронных вычислений в параллельном потоке.
 // Реализует интерфейсы Future и Runnable.
 У него есть методы для запуска (и остановки) какого-то вычисления, и также методы для получения результатов
 этих вычислений, в будущем.
 // Методы run(), get();
 А результат вычислений - будет получен только тогда, когда вычисление завершено. А до тех пор - метод получения
 результата будет заблокирован.
 В конструктор он принимает объекты Runnable и Callable.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что такое FutureTask?', 16);

INSERT INTO answers_mt (answer) VALUES (
'Взаимная блокировка (deadlock) - это такое явление, когда все потоки находятся в режиме ожидания и
 при этом ничего не делают.
 Какие могут быть причины:
 - взаимное исключение: когда какой-то один ресурс занят, и два или несколько потоков не могут его поделить.
 - цикличное ожидание: когда поток ждет освобождения ресурса другим потоком, а тот поток ждёт освобождения ресурса,
 заблокированного первым потоком.
 (Одно из часто встречающихся). (Можно привести пример со стульями).
 Чтобы не допустить взаимной блокировки, надо просто не допускать цикличного ожидания.
 Т.е можно освобождать мониторы ,разделяемых ресурсов, в обратном порядке. Т.е. если они блокировались в одном порядке,
 то освобождать в другом порядке.
 Ну еще надо как-то изначально правильно строить архитектуру своего многопоточного приложения.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что такое deadlock?', 17);

INSERT INTO answers_mt (answer) VALUES (
'livelock – это тоже взаимная блокировка, когда несколько потоков выполняют бесполезную работу.
 Когда они пытаются получить какие-либо ресурсы, то они зацикливаются. И при этом их состояния могут постоянно изменяться.
 Есть такой пример из жизни: – Когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым,
 отходит в сторону, и так они бесконечно двигаются из стороны в сторону, и при этом не продвигаются в нужном им направлении.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что такое livelock?', 18);

INSERT INTO answers_mt (answer) VALUES (
'Race condition - это состояние гонки, т.е. это когда программист как-то неправильно спроектировал свое
 приложение... многопоточное.
 И когда поток, который должен исполнится в самом начале, проиграл гонку другому потоку и первым исполняется вот этот другой поток.
 Затем - поведение кода может измениться, и из-за этого возникают ошибки.
 Есть два распространенных типа состояния гонки:
 DataRace (Гонка данных) - это когда потоки гонятся за данными. И начинают конфликтовать между собой (например,
 когда идет: чтение или запись в одну и ту же переменную).
 Starvation (Голодание) - это когда происходит нехватка данных, (и при этом потоки не заблокированы), из-за этого
 потоки просто ничего не делают.
 Например - потоки с низким приоритетом голодают, потому что потоки с высоким приоритетом - все ресурсы расхватывают
 намного быстрее, в первую очередь.
 Чтобы решить проблему стостояния гонок - можно синхронизировать потоки специальными методами или синхронайзед-блоками.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что такое race condition?', 19);

INSERT INTO answers_mt (answer) VALUES (
'Fork/Join - это такой фреймворк для работы с потоками. Он короче - разбивает задачи на более мелкие подзадачи,
 которые могут выполняться парралельно.
 Есть два этапа, у него:
 Этап Fork: большая задача разделяется на более мелкие - до тех пор, пока одна из задач не станет настолько простой,
 что решить ее можно последовательно.
 Этап Join: это когда решения подзадач начинают объединяться, до тех пор, пока не получится решение всей задачи полностью.
 Все это происходит параллельно. Потом...
 для решения некоторых задач этап Join не требуется.
 Ещё одно преимущество этого фреймворка заключается в том, что он использует алгоритм work-stealing:
 это значит что - потоки которые закончили свои подзадачи, могут «украсть» подзадачи у других потоков,
 которые всё ещё заняты. То есть оказывают им помощь.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что такое Фреймворк fork/join? Для чего он нужен?', 20);

INSERT INTO answers_mt (answer) VALUES (
'Synchronized предназначено для синхронизации потоков в методах или synchronized-блоках.
 Если блок кода пометить как - synchronized, то компилятор заменяет его тремя кусками кода:
 1) В начале блока добавляется код, который отмечает мютекс как занятый.
 2) В конце блока добавляется код, который отмечает мютекс как свободный.
 3) А перед блоком (synchronized-блоком) добавляется код, который смотрит, если мютекс занят – то все остальные
 потоки должны ждать его освобождения.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что означает ключевое слово synchronized? Где и для чего может использоваться?', 21);

INSERT INTO answers_mt (answer) VALUES (
'У статического - является объект типа Class, ну смотря, в каком классе определен метод.
 Если мы создаем объект статического (вложенного) класса, - все что находится в этом объекте – принадлежит
 статическому классу.
 Потом, в случае вызова статического метода - память выделяется только один раз.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что является монитором у статического синхронизированного класса?', 22);

INSERT INTO answers_mt (answer) VALUES (
'Здесь монитором будет объект this.
 А если вызывается нестатический синхронизированный метод, то память выделяется многократно, каждый раз,
 т.е. при каждом вызове метода.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Что является монитором у нестатического синхронизированного класса?', 23);

INSERT INTO answers_mt (answer) VALUES (
'java.util.concurrent - это пакет, который содержит в себе - специальные классы и интерфейсы для
 работы с потоками.
 - Concurrent Collections это — набор коллекций, для работы в многопоточной среде. Они более эффективные чем
 стандартные коллекции из java.util пакета. (collections) Например такие как: CopyOnWriteArrayList(Set), ConcurrentHashMap.
 Все операции по изменению коллекции (add, set, remove) приводят к созданию новой
 копии внутреннего массива. И этим гарантируется, что при проходе итератором по коллекции не будет выброшено исключение:
 ConcurrentModificationException.
 - Queues — это неблокирующие очереди и блокирующие очереди, с поддержкой многопоточности.
 Неблокирующие очереди работают быстрее блокирующих. И работают без блокирования потоков.
 Блокирующие очереди используются, когда нужно «притормозить» потоки, в зависимости от условий.
 Например, если очередь пуста или переполнена.
 - Executors - это интерфейс, который позволяют управлять потоками, и выполнять какие то задачи.
 Внутри него только один метод exequte();
 - ExecutorService -  наследник интерфейса Executor. Предназначен для управления пулом потоков.
 Имеет метод: execute(Runnable thread), который пришел от Executorsa; И метод: Метод shotdown().
 - Lock — интерфейс. Его объекты блокируют доступ к ресурсам или блокам. Намного удобнее чем synchronized.
 Методы: lock(), unlock(), trylock().
 - Atomic - Классы - для выполнения атомарных операций. Преимущество этих классов в том, что можно не использовать
 всякие там блокировки, и синхронизации (synchronized).
 - Synchronizers - вспомогательные утилиты для синхронизации потоков. С помощью них можно управлять или ограничивать
 работу нескольких потоков.
 Synchronizers содержит пять объектов синхронизации: semaphore, countDownLatch, ciclycBarrier, exchanger, phaser.
 -- Semaphore – это синхронизатор со счётчиком. При создании синхронизатора, изначальное значение счетчика задается в
 конструкторе. Когда поток заходит в заданный блок кода, то значение счетчика уменьшается на единицу,
 а когда поток его покидает, то увеличивается. Если значение счетчика равно нулю, то текущий поток блокируется,
 пока кто-нибудь не выйдет из защищенного блока.
 -- CountDownLatch - тоже для синхронизации потоков. Он будет блокировать потоки до тех пор, пока не будут выполнены
 определенные условия. Количество условий задается счетчиком. При обнулении счетчика, т.е. при выполнении всех условий,
 блокировки выполняемых потоков будут сняты, и потоки продолжат выполнение кода. (Используется один раз).
 -- CyclicBarrier — барьерная синхронизация, останавливает поток в определенном месте в ожидании прихода остальных
 потоков группы. Как только все потоки достигнут барьера, барьер снимается и выполнение потоков продолжается.
 Здесь тоже используется счетчик, как в CountDownLatch. Только здесь барьер можно использовать повторно(в цикле).
 -- Phaser — тоже как «Барьер», только в отличие от CyclicBarrier, может иметь несколько барьеров (фаз),
 и количество потоков на каждой фазе может быть разным.
 -- Exchanger — используется синхронизации потоков, а также для обмена данными между двумя потоками.
 При обмене данными допускается null значения.
 Обмен данными между потоками происходит только после вызова метода exchange() у обоих потоков.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Библиотека java.util.Concurrent поверхностно.', 24);

INSERT INTO answers_mt (answer) VALUES (
'Stream (интерфейс) - это последовательность элементов, над которой можно производить разные операции.
 - Внутри этого Stream API есть способы распараллеливания потока. Один из них - метод parallelStream().
 Метод parallelStream() - (он по умолчанию) использует ForkJoinPool.commonPool.
 // Собственно, поэтому они и связаны (Stream API и ForkJoinPool).
 Ну а ForkJoinPool – он также используется в ExecutorService (пулл потоков).
 И предназначен для выполнения параллельных задач.'
);
INSERT INTO questions_mt (question, answer_id) VALUES ('Stream API & ForkJoinPool Как связаны, что это такое.', 25);


-- src/main/resources/db/db.db.migration/V3__insert_sql.sql
-- SQL
INSERT INTO answers_sql (answer) VALUES (
'DDL (Data Definition Language) — обозначает - язык определения данных (декларативный метод).
 Это такая группа операторов, для работы с таблицами и со структурами этих таблиц.
 Они описывают - как данные должны храниться в этих таблицах.
 То есть все что касается: создание таблицы, удаление таблицы, создание или удаление полей в таблицах, и.т.д.
 // Его команды автоматически фиксируются. Поэтому все изменения сразу-же сохраняются в базе данных,
 и откатить обратно их уже нельзя.
 В DDL входят следующие команды:
 CREATE – создает: базы данных, таблицы, индексы, процедуры хранения, функции, триггеры, и другие объекты.
 ALTER  – изменяет структуру уже существующей базы данных, таблицы, и.т.д.
 DROP   – удаляет объекты из базы данных, т.е. таблицы.
 TRUNCATE – удаляет все записи из таблицы; // кроме того, удаляются все места, выделенные для записей.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое  DDL? Какие операции в него входят? Рассказать про них.', 1);

INSERT INTO answers_sql (answer) VALUES (
'(Data Manipulation Language) - группа операторов для манипуляции данными (императивный метод).
 Т.е. Это все операции, которые изменяют данные в БД. Например: добавление, получение, изменение и удаление.
 Команды DML не фиксируются автоматически. Поэтому изменения не сохраняются сразу и операцию можно откатить
 (в отличии от DDL).
 Только, если мы применим оператор COMMIT, то тогда, помоему можно данные сразу зафиксировать в БД.
 Короче DML предназначен для работы с данными в таблицах. В него входят следующие команды:
 SELECT - он выбирает данные по каким-то заданным условиям.
 INSERT - добавляет новые данные.
 UPDATE - изменяет уже существующие данные.
 DELETE - удаляет данные при выполнении условия WHERE; Например: DELETE * FROM Имя_таблицы WHERE ID=5;
 Если удалить без WHERE - то он все удалит.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое  DML? Какие операции в него входят? Рассказать про них.', 2);

INSERT INTO answers_sql (answer) VALUES (
'операторы управления транзакциями (Transaction Control Language):
 BEGIN     - определяет начало транзакции
 COMMIT    - применяет транзакцию (фиксирует).
 ROLLBACK  -  откатывает все изменения, сделанные после какой-то транзакции.
 SAVEPOINT -  разбивает транзакцию на более мелкие.
 // SET TRANSACTION - устанавливает параметры для текущей транзакции.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое  TCL? Какие операции в него входят? Рассказать про них.', 3);

INSERT INTO answers_sql (answer) VALUES (
'операторы определения доступа к данным (Data Control Language). Отвечают за безопасность:
 GRANT   - дает пользователю (или группе пользователей) какие-то разрешения на какие-то определенные операции с объектом.
 REVOKE  - отзывает -  ранее выданные разрешения.
 DENY    - он вообще запрещает делать какие-то операции с объектом;'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое  DCL? Какие операции в него входят? Рассказать про них.', 4);

INSERT INTO answers_sql (answer) VALUES (
'NULL означает отсутствие данных или неизвестность информации.
 Значение NULL не принадлежит ни одному типу данных.
 // Поэтому NULL не равно ни логическому значению FALSE, ни пустой строке, ни 0.
 Если сравнить NULL с любым значением, результат будет тоже NULL. Не FALSE и не 0. Более того, NULL не равно NULL.
 (Так как неизвестно что там лежит).
 Проверить поле на NULL можно с помощью команд: IS NULL, IS NOT NULL.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Нюансы работы с NULL в SQL. Как проверить поле на NULL?', 5);

INSERT INTO answers_sql (answer) VALUES (
'JOIN - оператор языка SQL, который выбирает данные из двух таблиц и соединяет эти данные в один результат,
 т.е. он как бы сцепляет их в одну таблицу.
 Например у нас есть таблица с котиками, и в каждой таблице есть имя котика и ID на следующую таблицу.
 А в той таблице для каждого котика имеется название кошачьего корма. Мы можем соединить эти две тоблицы,
 так как ID внешнего ключа и первичного ключа могут совпадать.
 Соединение значит, вот-так происходит:
 - в какую-то результирующую таблицу входят столбцы обеих исходных таблиц. Они как бы сцепляются между собой,
 т.е. из двух таблиц получается одна.
 - каждая строка таблицы-результата - это результат сцепления двух соединенных строк.
 - если надо соединить не две, а нескольких таблиц, то операция соединения применяется
 несколько раз (последовательно). Например: 1-2, 1-3, 1-4, 1-5, и.т.д.
 Какие существуют типы JOIN?
 // Outer - означает внешний.
 Inner-Join - соединяет только те записи (строки), для которых нашлись пары. Остальные он просто пропускает.
 Left-Join  - соединяет все записи с первой таблицы, а для ненайденных записей из второй таблицы проставляет значения Null.
 Right-Join - делает наоборот, т.е. соединяет все записи из второй таблицы, а на место нехватающих данных с первой
 таблицы - подставляет Null.
 Outer-Join - Работает, как одновременно левый и правый Joinы, и соединяет все записи из обеих таблиц.
 Также называется (Full-Join).
 Cross-Join - Тоже соединяет обе таблицы. Только там используется - декартово произведение.
 Самый простейший пример записи: select * from Имя_первой_таблицы join Имя_второй_таблицы;
 // Разница Join от Union - Join - объединяет таблицы, а Union объединяет запросы.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Виды Join’ов?', 6);

INSERT INTO answers_sql (answer) VALUES (
'Так как JOIN позволяет соединять несколько записей из таблиц одновременно, то лучше использовать его.
 Особенно, JOIN лучше всего применять, если нужно выбрать столбцы более чем из одной таблицы.
 Да и потом он лучше оптимизируется СУБД, поэтому лучше использовать JOIN.
 - Подзапросы же лучше использовать, когда надо вычислять агрегатные значения, т.е. значения каких-то столбцов,
 для того чтобы их сравнивать между собой.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что лучше использовать join или подзапросы? Почему?', 7);

INSERT INTO answers_sql (answer) VALUES (
'UNION - объединяет результы двух SQL-запросов в одну таблицу. Т.е. делает объединение двух SELECTов.
 Например, мы пишем: select Имя_столбца from Имя_таблицы union select Имя_столбца from Имя_таблицы;
 - И он берет нам все в один столбик запихивает.
 Оба запроса должны возвращать одинаковое число столбцов, а типы данных в столбцах должны быть одинаковыми.
 Потом - UNION, он не гарантирует порядок записей. И поэтому записи двух запросов могут перемешаться между собой.
 А если нужно сделать чтобы все шло по порядку, то можно использовать ORDER BY. (ORDER BY - он как раз сортирует
 все данные по порядку).
 Потом есть еще UNION ALL. И вот разница между ними в том, что UNION отсеивает дубликаты записей, а UNION ALL
 соединяет все вместе с дубликатами.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что делает UNION?', 8);

INSERT INTO answers_sql (answer) VALUES (
'// Агрегатные функции это такие как: SUM, MIN, MAX, AVG, COUNT.
 - WHERE - создает условия на ограничения строк.
 - HAVING - создает условия на ограничения строк по каким-то агрегатным функциям.
 - Отличаются они тем что:
 - WHERE нельзя использовать с агрегатными функциями, HAVING можно (предикаты тоже).
 В WHERE использовать алиясы можно всегда, а в HAVING не всегда. Можно, если надо создать псевдоним для результата
 агрегатной функции.
 В WHERE нельзя добавлять какое-то условия для GROUP_BY, а в HAVING можно.
 - WHERE используются вместе с операциями SELECT, UPDATE, DELETE.
 - HAVING используется только с SELECT (и GROUP BY).'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Чем WHERE отличается от HAVING ?', 9);

INSERT INTO answers_sql (answer) VALUES (
'ORDER BY - сортирует данные (по умолчанию - по возрастанию). С помощью кл. слов: ASC и DESC можно сделать
 возрастание или убывание для каждого столбца.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое ORDER BY?', 10);

INSERT INTO answers_sql (answer) VALUES (
'GROUP BY - он распределяет записи по группам, ну смотря какие мы укажем атрибуты.
 Он группирует даже по NULL.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое GROUP BY?', 11);

INSERT INTO answers_sql (answer) VALUES (
'DISTINCT - выводит в столбце только уникальные значения.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое DISTINCT?', 12);

INSERT INTO answers_sql (answer) VALUES (
'Лимитирует, т.е. ограничивает выборку заданным числом.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое LIMIT?', 13);

INSERT INTO answers_sql (answer) VALUES (
'EXISTS - проверяет, существует ли какая-либо запись или нет. Возвращает True или False.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое EXISTS?', 14);

INSERT INTO answers_sql (answer) VALUES (
'• IN - пробегается по списку, и если указанное значение есть, то вытаскивает его.
 Например: SELECT * FROM Имя_табл. WHERE name IN ("Ivan","Petr","Pavel");
 • BETWEEN определяет диапазон значений. Например между 20 и 25. (Чувствителен к порядку) Пример:
 SELECT * FROM Имя_табл. WHERE age BETWEEN 20 AND 25;
 • LIKE - работает, в основном с полями VARCHAR (или CHAR). Это - что-то наподобие РЕГУЛЯРНЫХ ВЫРАЖЕНИЙ!
 Используется чтобы находить подстроки и замещает любой одиночный символ. Например пишем:
 SELECT * FROM Имя_таблицы WHERE NAME LIKE "%а"; (Саша, Даша, Маша..)'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Расскажите про операторы IN, BETWEEN, LIKE.', 15);

INSERT INTO answers_sql (answer) VALUES (
'MERGE - короче, я так понял - он берет одну таблицу, и накладывает ее на другую таблицу.
 Таким образом происходит слияние этих таблиц.
 Если там есть какая-то одинаковая строка - то он просто обновляет ее данные (выполняется UPDATE), а если нет,
 то он вставляет туда новую строку из первой таблицы (INSERT).'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что делает оператор MERGE? Какие у него есть ограничения?', 16);

INSERT INTO answers_sql (answer) VALUES (
'Агрегатных функции - это такие функции, которые получают на вход имя какого-то столбца или столбцов,
 и делают вычисления со значениями этого столбца (поля).
 Например у нас есть таблица с мобильными телефонами и их ценами. И чтобы вычислить среднюю цену,
 можно применить функцию AVG();
 Несколько агрегатных функций:
 COUNT - подсчитывает все записи, по условию запроса;
 CONCAT - соединяет строки (из указанных столбцов);
 SUM - вычисляет сумму всех значений колонки;
 AVG - вычисляет среднюю величину всех значений;
 MAX - находит максимальное значение из всех выбранных значений;
 MIN - находит минимальное значение из всех выбранных значений.
 Также есть LOWER, UPPER.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Какие агрегатные функции вы знаете?', 17);

INSERT INTO answers_sql (answer) VALUES (
'Ограничения - это ключевае слова, которые устанавливают правила, для размещения данных в таблице, или в базе.
 NOT NULL - указывает, что значения в этой колонке не может быть NULL, т.е. не может быть пустым.
 UNIQUE - отсеивает дубликаты. Т.е. не позволяет размещать в колонке повторяющиеся значения.
 PRIMARY KEY - (первичный ключ) это комбинация NOT NULL и UNIQUE. Помечает каждую запись в базе данных уникальным значением.
 Например ID.
 CHECK - он - проверяет вписывается ли значение в заданный диапазон или нет. ( s_id int CHECK(s_id > 0) )
 FOREIGN KEY создает связь между двумя таблицами. Является внешним ключом. FOREIGN KEY в одной таблице указывает
 на PRIMARY KEY в другой.
 DEFAULT устанавливает значение по умолчанию, если никакое значение не предоствлено. (name VARCHAR(20) DEFAULT "noname").'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое ограничения (constraints)? Какие вы знаете?', 18);

INSERT INTO answers_sql (answer) VALUES (
'Суррога?тный ключ — это что-то наподобие первичного ключа, только работает немного по другому.
 Например: Нам нужно чтобы уникальные значения были строковыми, или символьными.
 Здесь - уникальные значения также могут генерироваться автоматически.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое суррогатные ключи?', 19);

INSERT INTO answers_sql (answer) VALUES (
'Индексы - это такие механизмы, которые ускоряют производительность, т.е. позволяют быстрее извлекать записи из таблицы.
 (Это как страница книги).
 Хоть пользователь их не видит, но они там есть.
 Индекс - он формируется из значений одного или нескольких записей и указателей на соответствующие записи набора данных.
 Когда мы добавляем или удаляем индексы - то мы никак не влияем на сами данные.
 Они создают структуру для индексируемых полей.
 Есть три типа индексов, а именно:
 -Уникальный индекс: этот индекс позволяет полю иметь уникальные значения. Если первичный ключ определен,
 уникальный индекс применяется автоматически.
 -Кластеризованный индекс: сортирует и хранит строки данных в таблицах на основе их ключевых значений.
 // Это ускоряет операции чтения из БД.
 -Некластеризованный индекс: он в отличие от кластерного, не перестраивает структуру набора данных, он просто
 организуют ссылки на соответствующие записи.
 Короче разница в чем: Кластерный индекс упорядочивает данные физически, а не кластерный не упорядочивает данные физически,
 но все-таки связывает данные логически при помощи ссылок.
 Как создать индекс?
 Индекс можно создать либо с помощью: CREATE INDEX. Например:
 CREATE INDEX имя_индекса ON имя_таблицы(имя_колонки)
 либо при создании таблицы, когда мы создаем первичный ключ и указываем UNIQUE то это тоже считается индексом.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое индексы? Какие они бывают?', 20);

INSERT INTO answers_sql (answer) VALUES (
'DELETE - оператор DML, удаляет записи из таблицы. (которые удовлетворяют условиям WHERE). Медленнее, чем TRUNCATE.
 Есть возможность восстановить данные.
 - TRUNCATE - DDL оператор, удаляет все строки из таблицы. Нет возможности восстановить данные - сделать ROLLBACK.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Чем TRUNCATE отличается от DELETE?', 21);

INSERT INTO answers_sql (answer) VALUES (
'Хранимая процедура — такой же метод как и в обычном ЯП, и она хранится на сервере.
 В хранимых процедурах могут выполняться обычные операции с базами данных (как DDL, так и DML).
 Они повышают производительность, и обеспечивают безопасность данных.
 Также они расширяют кое-какие возможности программирования.
 В большинстве СУБД, хранимые процедуры находятся в скомпилированном виде, благодаря чему обработка данных
 происходит быстрее.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое хранимые процедуры? Для чего они нужны?', 22);

INSERT INTO answers_sql (answer) VALUES (
'View - это такая виртуальная таблица, которая представляет данные таблиц каким-то альтернативным образом.
 Т.е. как-то по другому.
 Т.е. можно из двух таблиц слепить одну таблицу, или можно сделать так, чтобы таблица выводила только те
 столбцы - которые нужны, а которые не нужны скрыть.
 Вот эти виртуальные таблицы (View), они не содержат никаких собственных данных.
 Таким образом расширяются возможности управления данными.
 Представления можно создавать как из таблиц, так и из других созданных представлений, т.е. они могут быть
 вложенными (до 32 уровней вложенности).'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое представления (VIEW)? Для чего они нужны?', 23);

INSERT INTO answers_sql (answer) VALUES (
'Временные таблицы - это как черновик. Например мы можем сделать выборку данных из нескольких таблиц, поработать
 с этими данными какое-то время и затем удалить эту временную таблицу.
 Чтоб создать временную таблицу, нужно использовать один знак решетки # или два знака решетки ##.
 Если используется один знак #, то создается локальная таблица, она доступна в течение текущей сессии.
 Ели используются два знака ##, то создается глобальная временная таблица.
 Глобальная временная таблица доступна для всех открытых сессий, а локальная только для текущей.
 Пример: CREATE TABLE #Имя_таблицы
 (Id INT, Name VARCHAR(20));
 Срок жизни временной таблицы – это сеанс с БД.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое временные таблицы? Для чего они нужны?', 24);

INSERT INTO answers_sql (answer) VALUES (
'Транзакция - это выполнение нескольких операций за один шаг. Несколько операций - как одно целое.
 При этом целостность структуры данных не нарушается.
 Т.е. когда мы выполняем несколько действий (т.е. транзакцию). И если хоть одно действие не будет выполнено,
 то и все остальные не будут выполнены.
 Принципы ACID для транзакций:
 • Атомарность (atomicity) - Гарантирует что транзакция будет выполнена полностью, либо не будет выполнена совсем.
 Без промежуточных состояний.
 • Согласованность (consistency). - Означает что - транзакция, которая успешно выполнилась - фиксируется и
 сохраняется в базе данных.
 • Изолированность (isolation). - Означает что - во время выполнения транзакции, параллельные транзакции не должны
 влезать в ее работу.
 Т.е. каждая транзакция независима и изолирована.
 • Долговечность (durability). - Какие-бы проблемы не произошли (Например: потеря питания, сбой или ошибки любого рода)
 - если транзакция успела завершиться, то при возобновлении работы системы - все будет также сохранено. А если нет,
 то все также и останется, а данные при этом не будут повреждены.
 (Надежность) Если пользователь получил от системы уведомление что транзакция выполнена, то он может быть уверен - что
 изменения не будут отменены.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое транзакции? Расскажите про принципы ACID.', 25);

INSERT INTO answers_sql (answer) VALUES (
'// Во первых есть такое понятие - как \"Грязное чтение данных\". Это означает, что когда мы читаем данные во время
 выполнения какой-то другой транзакции, мы
 можем прочитать какой-то один результат, а после завершения той транзакции - результат может быть совершеннно другим.
 // \"Неповторяющееся чтение\" - это когда при повторном чтении, пока транзакция не завершилась - прочитанные данные
 могут оказаться измененными;
 // \"Фантомное чтение\" - это когда одна транзакция несколько раз выбирает какие-то записи, и по одним и тем же критериям.
 А другая транзакция в то же время проделывает с этими записями какие-то операции.
 • Чтение неподтверждённых данных (read uncommitted) — чтение каких-то незафиксированных изменений во время транзакции.
 Нет гарантии, что при таком чтении (его еще называют грязное чтение), данные не будут изменены после завершения транзакции.
 (Пример с яблоками).
 • Чтение подтвержденных данных (read committed) — чтение всех изменений, уже после выполнения транзакций.
 • Повторяемость чтения (repeatable read) — Уровень, позволяющий читать данные повторно.
 Т.е. чтение всех изменений транзакции.
 Данные обновились, и он еще раз их может считать.
 • Упорядочиваемость (serializable) — это означает, что пока не будет выполнена одна транзакция, другие транзакции
 не будут выполняться. Т.е. они как бы выполняются в последовательном порядке. Таким образом транзакции изолированы
 друг от друга еще лучше, чтобы не мешать друг другу.
 - Уровни изолированности транзакций идут в порядке увеличения. Соответственно, надежность работы с данными также
 увеличивается.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Расскажите про уровни изолированности транзакций.', 26);

INSERT INTO answers_sql (answer) VALUES (
'// Нормализация - это процесс приведения в нормальные формы.
 - Нормализация - разбиение таблиц на более мелкие, благодаря чему избыточные данные удаляются.
 (Таким образом данные не дублируются).
 - Денормализация - обратный процесс. Это делается для повышения производительности и скорости извлечения данных.
 Существуют несколько типов нормальных форм, вот три из них:
 - Первая нормальная форма - это когда значения всех полей атомарны (т.е. неделимы).
 - Вторая нормальная форма - это когда все неключевые поля целиком зависят от какого-то одного ключа. Например,
 когда мы не можем удалить таблицу, так как от нее зависит другая таблица, т.е. ее ключи привязаны к той первой таблице.
 - Третья нормальная форма - все неключевые поля не зависят друг от друга.
 Также есть нормальная форма Бойса-Кодда - Но я, короче о ней ничего не знаю. (Каждая ее нетривиальная и неприводимая
 форма находится слева).
 - И еще каждая нормальная форма включает в себя предыдущую.'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое нормализация и денормализация? Расскажите про 3 нормальные формы?', 27);

INSERT INTO answers_sql (answer) VALUES (
'TIMESTAMP - это специальный тип данных в SQL, который расширяет возможности типа данных DATE.
 Он хранит в себе секунды с 1 января 1970 года (по Гринвичу). Тогда была создана Unix. У TIMESTAMPа очень высокая
 точность по сравнению с DATETIME.
 TIMESTAMP можно как-то преобразовать в DATE и в DATETIME. (Вроде-бы с помощью функции Cast()).
 Данные TIMESTAMPа отображаются с учётом часового пояса. Размер: 4 байта.
 (DATETIME предназначен для хранения целого числа: YYYYMMDDHHMMSS. И это время не зависит от временной зоны
 настроенной на сервере. Размер: 8 байт).'
);
INSERT INTO questions_sql (question, answer_id) VALUES ('Что такое TIMESTAMP?', 28);


-- src/main/resources/db/db.db.migration/V3__insert_hibernate.sql
-- HIBERNATE
INSERT INTO answers_hibernate (answer) VALUES (
'ORM(Object Relational Mapping) - это концепция преобразования объекта в строку в таблице БД и наоборот.
 JPA(Java Persistence API) - это такая спецификация для Java, которая описывает принципы ORM. Т.е. каким образом
 сохраняется объект в таблице БД и наоборот. // JPA не работает с объектами, а только определяет правила как должны
 действовать провайдеры. Например Hibernate - является одним из этих провайдеров. Также // еще есть EclipseLink и др.
 Hibernate - библиотека, она как раз реализует эту спецификацию JPA, работает по ее правилам. Это такой слой между
 базой данных и приложением на Java.
 // Сначала появился Хибер, а потом по нему уже сделали JPA. На основании Хибера создали стандарт JSR.
 Важные интерфейсы Hibernate:
 * Session - соединяет (физически) приложение с БД. С помощью нее можно выполнять DML-операции в базе данных через
 объектно-ориентированные сущности.
 * SessionFactory - это фабрика для объектов Session. Она создается при запуске приложения и может использоваться
 всеми потоками приложения.
 Пример: Session session = sessionFactory.openSession();
 * Transaction - однопоточный короткоживущий объект, используемый для атомарных операций.
 В одной Session может быть несколько Transactionов.
 * Query - это такой интерфейс, с помощью него можно выполнять запросы к БД с помощью языков HQL или на SQL.
 Пример:
 Query query = session.createQuery(\"from Human where name = "Yura");
 List list = query.list();
 // HQL - Hibernate Query Language - это язык для объектно-ориентированных запросов.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Что такое ORM? Что такое JPA? Что такое Hibernate?', 1);

INSERT INTO answers_hibernate (answer) VALUES (
'EntityManager это интерфейс JPA. Он управляет сущностями Entity, он не является потокобезопасным.
 Он содержит внутри себя методы - необходимые для операций над сущностью и ее данными.
 EntityManager - создается с помощью фабрики EntityManagerFactory.
 Пример: EntityManager entityManager = entityManagerFactory.createEntityManager();
 Основные операции:
 1) Операции над Entity (методы): persist (сохраняет Entity в БД), merge (обновление данные в БД в соответствии
 с сущностью, которую ему передали),
 remove (удаление), refresh (обновляет данные сущности из БД),
 detach (выводит из под контроля EntityManagera), lock (блокирование Entity от изменений в других потоках).
 2) Получение данных: find(поиск Entity), createQuery(), createNamedQuery(), createNativeQuery(), contains(),
 createStoredProcedureQuery().
 3) Получение других сущностей JPA: getTransaction(), getEntityManagerFactory(), getCriteriaBuilder(),
 getMetamodel(), getDelegate
 4) Работа с EntityGraph: createEntityGraph(), getEntityGraph().
 5) Общие операции над EntityManager или над всеми Entities: close(), clear(), isOpen(), getProperties(),
 setProperty().
 // EntityManager работает с PersistentContextom - внутри которого находится набор, либо вновь созданных сущностей,
 либо выгруженных из БД.
 // В JPA EntityManager идет как аналог Session в Hibernate.
 // Объекты EntityManager не являются потокобезопасными. Это означает, что каждый поток должен получить свой
 экземпляр EntityManager, поработать с ним и закрыть его в конце.
 >> С помощью Entity Graph можно менять стратегию FetchType.EAGER или FetchType.LAZY во время выполнения программы.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Что такое EntityManager? Какие функции он выполняет?', 2);

INSERT INTO answers_hibernate (answer) VALUES (
'Entity это - легковесный хранимый объект бизнес логики.
 - А если по простому, Entity - это сущность (POJO-class) которая может быть сопоставлена с таблицей в реляционной БД.
 Получается - сущность Entity будет являться таблицей в БД, а каждый экземпляр Entity будет являться строкой в БД.
 1) Entity класс должен быть помечен аннотацией Entity или описан в XML файле
 2) Entity класс должен иметь пустой конструктор (без аргументов, публичный или протектед). // И иметь сеттеры и геттеры.
 Потому что - при получении данных из БД, Hibernate, из полученных данных, формирует объект сущности.
 3) Entity класс должен быть классом верхнего уровня. Т.е. класс не должен быть вложенным.
 4) Entity класс не может быть enum или интерфейсом.
 5) Entity класс не может быть финальным классом (final class).
 6) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге.
 (А если не участвуют, то можно).
 7) Если объект Entity будет передаваться по значению как отдельный объект, например через удаленный интерфейс,
 он должен реализовывать Serializable.
 8) Поля Entity класса должны быть доступны только методам самого Entity и не должны быть напрямую доступны другим
 классам, использующим этот Entity. Такие классы должны обращаться только к getterам, setterам или другим его методам.
 9) Entity класс должен быть с аннотацией @ID, которая идентифицирует первичный ключ, который делает его уникальным
 при записи этого Entity в базе данных.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Каким условиям должен удовлетворять класс чтобы являться Entity?', 3);

INSERT INTO answers_hibernate (answer) VALUES (
'Может. Так как он сохраняет все свойства Entity. Но только его нельзя непосредственно инициализировать.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Может ли абстрактный класс быть Entity?', 4);

INSERT INTO answers_hibernate (answer) VALUES (
'Может.
 Но только состояния полей обычного класса-родителя не могут быть персистентным, и не смогут сохраняться в БД,
 и вообще не будут обрабатываться Hibernatом.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?', 5);

INSERT INTO answers_hibernate (answer) VALUES (
'Да. Может. // Ну просто может. Таковы правила в Hibernate.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Может ли Entity класс наследоваться от других Entity классов?', 6);

INSERT INTO answers_hibernate (answer) VALUES (
'Тоже может. // Здесь - тоже самое с полями и их обработкой Hibernaitoм.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Может ли не Entity класс наследоваться от Entity класса?', 7);

INSERT INTO answers_hibernate (answer) VALUES (
'Встраиваемый класс - это класс, он не является самостоятельным, а является частью (компонентом) другого,
 какого-то одного или же нескольких Entity-классов.
 Внутри Entity-класса может находиться как один встраиваемый класс, так и коллекция встраиваемых классов.
 Также такие классы могут быть использованы как ключи или значения map.
 Во время выполнения программы, каждый встраиваемый класс принадлежит только одному объекту Entity-класса и не может
 быть использован кем-то еще.
 - Требования к встраиваемым классам:
 1. В нем не требуется аннотация @Entity и @ID, а в остальном они должны соблюдать те же правила что классы Entity.
 2. Поле этого класса внутри Entity должно быть с аннотацией @Embedded.
 А сам Embeddable-класс помечается аннотацией @Embeddable (или описан в XML файле конфигурации JPA).
 Также Embeddable-класс может, внутри себя, содержать другой (Embeddable) встраиваемый класс.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Что такое встраиваемый (Embeddable) класс?
                                                               Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?', 8);

INSERT INTO answers_hibernate (answer) VALUES (
'Mapped Superclass - это класс, от которого может наследоваться Entity, но при этом ему не обязательно
 выполнять все требования как в Entity.
 Он помечается аннотацией @MappedSuperClass (или описывается в xml файле).
 В нем не требуется первичный ключ. В нем не прописывается аннотация @Entity.
 И классы которые наследуются от него, они получают состав своей структуры, т.е. все поля перечисленные в том классе.
 - Общее между Embeddble и Mapped Superclassom - то что они являются - общей структурой, которая потом передается
 в другие классы.
 И общее в том что они оба не являются Entity, соответственно не могут иметь своих таблиц в БД.
 И также не могут учавствовать в запросах EntityManagera и Query.
 А разница в том что - встраиваемые(Embeddble) классы они получается встраиваются как тип от названного класса,
 а Mapped Superclass - там транслируются поля от родителя, в структуру наследника.
 // Сам такой класс хоть и не является Entity, но может содержать некоторые анотации JPA.
 // С помощью MappedSuperclassа можно заранее определить свойства и методы, для сущностей. Это позволяет сократить
 количество кода.
 // Я так понял, это что-то наподобие абстрактного класса, но только он не является Entity.
 // Если унаследоваться от MappedSuperClassa каким то Entity, то таблица класса Entity будет создана, а таблица из
 MappedSuperClassa не будет.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Что такое Mapped Superclass?', 9);

INSERT INTO answers_hibernate (answer) VALUES (
'Стратегии наследования нужны для того, чтобы дать понять Hibernatу как ему надо отображать в
 БД сущностей-наследников.
 Для этого родительский класс помечается аннотацией @Inheritance и там нужно указать один из типов отображения:
 SINGLE_TABLE, TABLE_PER_CLASS, JOINED.
 1. SINGLE_TABLE. - это одна таблица. Когда предок и наследник записываются в одну таблицу (т.е. одна таблица для
 всей иерархии классов).
 И в ней создается специальная колонка (“discriminator column”). И в этой колонке идентифицируются, к какому
 типу(классу) относится данная запись.
 И формируются еще дополнительные колонки в которых сохраняются специфические данные.
 Например у нас предок Animal, а дальше - от нее идут наследники собака и кошка. Т.е. у кошки какие-то свои
 специфические данные и у собаки свои. И они не пересекаются. (Данная стратегия является стратегией по умолчанию).
 Минусом является то что у нас в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков,
 и они могут быть пустыми для всех остальных классов-потомков. И так как - на специфические типы, в колонках,
 мы не можем наложить ограничение NotNULL. И это может привести к неопределенному моменту.
 Например, в таблице animals окажется и скорость лазанья по дереву (от кошки) и может ли собака приносить палку.
 И они всегда будут иметь null, и для собаки и для кошки.
 В реляционной базе данных у нас нету классов. Там у нас есть типы. (Сказал В...).
 2. TABLE_PER_CLASS. - Это значит что у каждого конкретного класса-сущности будет своя собственная таблица,
 со всеми полями, включая поля родителя.
 Но у этой стратегии минус, в том что приходится делать несколько запросов, или объединять их через UNION.
 То есть не поддерживаются полиморфизм.
 3. JOINED. - Здесь создается общая таблица для предка и наследников. И в эту таблицу записываются общие данные.
 А для специфических данных создаются отдельные таблицы, и в них записываются уникальный ключ и специфические данные.
 Потом между этими таблицами дополнительно устанавливается связи. И если взять пример из классов Animals,
 то будут три таблицы: animals, cats, dogs.
 Т.е. в cats будет записаны: только ключ и скорость лазанья, в dogs — ключ и умеет ли собака приносить палку,
 а в animals все остальные данные.
 Минусом тут будет потери производительности из-за объединения таблиц (join) для каких-либо операций.
 Т.е. - когда у нас слишком большая иерархия выстраивается, и при большой иерархии может наступить определенный момент,
 после чего как-раз начинает теряться эта самая производительность. Т.е.когда иерархия достигает больших
 пределов наследования.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Какие три типа стратегии наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?', 10);

INSERT INTO answers_hibernate (answer) VALUES (
'Для того чтобы замапить Enum нужно использовать аннотацию @Enumerated. И мапятся они либо по имени,
 либо по порядковому номеру в Enume.
 И задается это в параметрах @Enumerated. (По умолчанию мапится по индексу - EnumType.ORDINAL).
 Недостаток EnumType.ORDINAL: Так как у нас в базе данных хранятся только индексы, они не привязаны к самому Enumu,
 т.е. значения. У нас получается,
 при добавлении элементов в СЕРЕДИНУ, в базе данных вся информация просто сбивается. И для этого у нас как раз
 вводят Stringи, чтобы в базе данных хранилось наименование Enuma. Это основной недостаток при хранении через ORDINAL.
 А если Stringoй храним, то соответственно у нас, при добавлении нового значения ничего не меняется, но при этом - если
 мы хотим переименовать саму константу,
 то у нас опять таки возникает ошибка - что теряется значение в базе данных, которое уже не соответствует ни одному
 значению из нашего Enuma.
 И для этого у нас две методологии появились:
 1. Написать свой конвертер. Пишем класс с аннотацией @Converter, и поле которое нужно мапить, мы его прописываем с
 аннотацией @Convert. И тогда будет использоваться класс соответствующий при конвертации этого Enuma.
 Потом (как сказал В...) Мы над полем Enumа, непосредственно который сам Enum - ставим аннотацию @Transient.
 А в базу данных уже именно значения конвертера с этого Enuma вносим.
 Например: Есть у нас сущность, а в ней поле Enum, которое обычным способом в БД ОРЭмится так сказать,
 то здесь - когда мы вводим конвертер (класс которого пишется отдельно), чтобы Enum при этом у нас уже не вносился в БД,
 а только конвертация этого Enuma, то как раз таки над Enumom мы и ставим @Transient.
 То есть - он в БД уже попадать не будет, а только значение конвертации.
 - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 - 1). По порядковым номерам.
 Для этого используется аннотация @Enumerated(EnumType.ORDINAL) - означает что в базе будут храниться порядковые
 номера Enum.
 При этом в таблице нашей сущности создаётся колонка для значений перечисления enum и по умолчанию в ячейки
 сохраняется порядковый номер этого перечисления.
 - 2). По именам.
 Здесь используется аннотация @Enumerated(EnumType.STRING). Это означает, что в базе будут храниться имена Enum.
 С @Enumerated(EnumType.STRING) можно добавлять значения перечисления или изменять порядок перечисления.
 Потребляет больше места, чем в случае с ORDINAL. И когда надо будет работать с большим объемом данных,
 то из-за этого могут возникнуть проблемы.
 - @Enumerated(EnumType.STRING) - означает, что в базе будут храниться имена Enum.
 Также - enum можно смапить, в БД и обратно, в методах с аннотациями @PostLoad и @PrePersist.
 Здесь сущность может содержать в себе не только поле с Enum, но и вспомогательное поле.
 (Вспомогательное поле нужно потому что у Enuma нет айдишника).
 Таким образом мы можем пометить поле с Enum аннотацией @Transient, а в БД будет храниться значения из этого
 вспомогательного поля.
 Также в JPA (с версии 2.1) можно использовать Converter для конвертации Enum’а в такое значение - чтобы его можно
 было сохранить в БД и получить из БД.
 Для этого нужно создать класс, который будет реализовывать интерфейс AttributeConverter и аннотировать его с помощью
 @Converter и поле в сущности аннотацией @Convert.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Как мапятся Enumы?', 11);

INSERT INTO answers_hibernate (answer) VALUES (
'До Java 8 даты можно было мапить с помощью аннотации @Temporal, в ее параметрах надо было указать какой
 тип даты мы хотим использовать.
 Пример: @Temporal(TemporalType.DATE) , @Temporal(TemporalType.TIME), @Temporal(TemporalType.TIMESTAMP).
 А после 8-ой Javы никакие аннотации уже не нужны. То есть - она сама определяет что это дата, и какой у нее тип.
 Там появился специальный пакет java.time. а до этого использовался пакет java.util.
 Разница между ними в том что в пакете java.util точность измерения до миллисекнуд, а в пакете java.time точность до
 наносекунд (т.е. в миллион раз выше).
 >>> Если что: Маппить на русском значит \"сопоставлять\".'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Как мапятся даты (до java 8 и после)?', 12);

INSERT INTO answers_hibernate (answer) VALUES (
'Чтобы смапить коллекцию примитивов - используется аннотация @ElementCollection. Она указывается в
 классе сущности над полем коллекции с примитивами.
 Для сохранения коллекции создается отдельная таблица. В итоге получим две таблицы: одна для сущности, а вторая
 для коллекции элементов.
 И в этой таблице никаких идентификаторов нет. Поэтому, если значение в коллекции изменяется, то - оно перезаписывает,
 полностью - все что там хранилось. Таблица очищается и заполняется заново.
 // Аннотация @ElementCollection похожа на отношение @OneToMany, только здесь используются базовые и встраиваемые типы,
 а не сущности.
 // При добавлении новой строки в коллекцию, она полностью очищается и заполняется заново, так как у элементов нет id.
 (Можно решить с помощью @OrderColumn).
 // @OrderColumn - указывает столбец, который используется для поддержания постоянного порядка в списке.
 // @CollectionTable - позволяет редактировать таблицу с коллекцией, прочитать.
 // Если у нашей сущности есть поле с коллекцией, то мы привыкли ставить над ним аннотации @OneToMany либо @ManyToMany.
 // Но такие аннотации применяются в случае, когда это коллекция других сущностей (entities).'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Как “смапить” коллекцию примитивов?', 13);

INSERT INTO answers_hibernate (answer) VALUES (
'Существуют 4 типа связей:
 1. OneToOne - когда один экземпляр Entity может быть связан не больше чем с одним экземпляром другого Entity.
 2. OneToMany - когда один экземпляр Entity может быть связан с несколькими экземплярами других Entity.
 3. ManyToOne - обратная связь для OneToMany. Несколько экземпляров Entity могут быть связаны с одним экземпляром
 другого Entity.
 4. ManyToMany - экземпляры Entity могут быть связаны с несколькими экземплярами друг друга.
 - - - - - - - - - - - - - - - - - - - - - - - - - - - -- -
 Каждый тип связи может быть однонаправленным и двунаправленным.
 - Однонаправленная связь - она предполагает что, один объект ссылается на другой, а в обратную сторону ссылки нет.
 А при двунаправленной связи - оба объекта знают друг про друга, т.е. хранят ссылку друг на друга.
 - - - - - - - - - - -- - - - - - - --  - - - --- --- - - -
 Каждую из которых можно разделить ещё на два вида:
 1. Bidirectional с использованием mappedBy на стороне, где указывается @OneToMany
 2. Unidirectional
 Bidirectional — ссылка на связь будет у обоих Entity, то есть в случае OneToOne A-B в Entity A есть ссылка на Entity B,
 в Entity B есть ссылка на Entity A. И при этом Entity A считается владельцем этой связи.
 Undirectional - ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у Entity A
 будет ссылка на Entity B, у Entity B ссылки на A не будет, и он даже знать не будет что на него кто-то ссылается.
 // Пример с автомобилями и их владельцем при удалении владельца.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Какие есть виды связей?', 14);

INSERT INTO answers_hibernate (answer) VALUES (
'Владелец связи это тот кто хранит ссылку (внешний ключ) на другую сущность.
 (т.е. есть владелец и есть владеемая сущность).
 И когда связь многие ко многим, то тут уже получается неопределенность, потому что - оба объекта хранят ссылки
 друг на друга.
 Но также можно и установить владельца связи вручную (Например в @ManyToMany - можно указать атрибут mappedBy).
 А вот аннотация @ManyToOne автоматически подразумевает что сторона Many - является владельцем, и поэтому у этой
 аннотации отсутствует атрибут mappedBy.
 - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 - В отношениях между двумя сущностями всегда есть одна владеющая сторона (а владеемой может и не быть).
 Это называется однонаправленное отношение.
 В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой
 связи по умолчанию.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Что такое владелец связи?', 15);

INSERT INTO answers_hibernate (answer) VALUES (
'Каскады (JPA CascadeType) - это связи между основной связанной сущностью и дочерней связанной сущностью (сущностями).
 Они определяют поведение со связанной сущностью в зависимости от состояния основной сущности.
 * Т.е если там будет ALL - то все что происходит с основной сущностью, то же будет происходить и со связанной.
 * Когда PERSIST -  означает, что операции save() или persist() каскадно передаются связанным объектам.
 * Когда MERGE - то когда объединяется основная сущность, тогда же объединяются и связанные сущности.
 * Потом - REMOVE, - это удаление основной сущности - вызовет удаление связанной сущности.
 * DETACH - также отключается из под управления JPA основная сущность и связанная сущность.
 * И REFRESH - это значит - из базы данных обновляются - основная сущность и связанная.
 //= Про удаление сирот - что можешь рассказать?
 //- orphan_removal - есть такой параметр у аннотаций взаимосвязей. В переводе сиротский приют называется.
 Т.е. когда мы удаляем родителя, и у нас в БД - //остаются сироты, как раз когда мы пишем - orphan_removal в каскаде,
 тип REMOVE либо ALL - у нас БД автоматически отыскивает этих сирот и удаляет.
 //Т.е. чтобы не засорять память в БД. Мы просто ставим аннотацию, но параметр orphan_removal и при удалении
 родительской сущности - дочерние удаляются //автоматически. Они не останутся в БД. Только будет происходить это
 автоматически, на уровне БД. Для этого нам достаточно просто указать как раз только
 //этот orphan_removal. Это указывается в видах связей, например в OneToMany (т.е. не в самих каскадах).
 OneToMany - и у нее есть один из параметров, это
 //orphan_removal (удаление сирот).
 >>> Родительская сущность (таблица) Это сущность (таблица), на которую ссылается внешний ключ из дочерней
 сущности (таблицы).
 >>> Дочерняя сущность (таблица) Это сущность (таблица), в которой есть колонка с внешним ключом, ссылающимся на
 родительскую сущность (таблицу).'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Что такое каскады?', 16);

INSERT INTO answers_hibernate (answer) VALUES (
'* LAZY - это ленивая загрузка, т.е. когда загружается основная сущность, а связанные не загружаются.
 Загрузка связанных сущностей произойдет только при первом обращении к ним.
 * EAGER - это жадная загрузка, там данные загружаются сразу, вместе с основной сущностью все связанные сущности
 тоже загружаются.
 - Значит, EAGER - загрузка по умолчанию установлена на все отношения которые заканчиваются на toONE, а также @Basic,
 там тоже он по умолчанию стоит.
 - А LAZY-загрузка, по умолчанию, на все, которые заканчиваются на toMany, а также и у @ElementCollection тоже по умолчанию.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Какие два типа fetch стратегии в JPA вы знаете?', 17);

INSERT INTO answers_hibernate (answer) VALUES (
'New - это когда объект создан, но еще не перешел под управление JPA.
 // и пока еще не имеет связи с базой данных, и не имеет первичных ключей.
 - Managed - это когда выполнена команда persist(), и сущность создана, и получает Primary Key, и сохраняется в БД.
 Устанавливается прямое соответствие меджду сущностью и записью в БД. //Здесь сущность получает primary key,
 и уже управляется JPA
 - Removed - это когда сущность еще управляется JPA, но при коммите она будет удалена.
 // И статус станет detached. А до тех пор объект все еще будет управляться JPA.
 (Мы его пометили на удаление, и до коммита он еще находится в контексте).
 - Detached - это сущность, которая уже вышла из под управления JPA. В этом состоянии сущность не связана со своим
 контекстом (отделена от него)
 и нет экземпляра Session, который бы ей управлял. (т.е. мы ее удалили из контекста).
 - - - - - - - - - -- - - - -- - - - - - - -- - - -- - - - - -- - - - - -  - -
 = А в каких статусах имеется первичный ключ?
 - В Managed, и в Removed (еще наверноое).'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можете перечислить?', 18);

INSERT INTO answers_hibernate (answer) VALUES (
'Из состояния new > (по команде persist()) переходит в состояние managed. Т.е. сущность получает первичный
 ключ и связь с БД.
 // Значит объект сущности будет сохранен в базу при commit-е транзакции или в результате flush() операций
 - Если уже находится в состоянии managed, то игнорируется.
 - Если detached, то будет exception. // сразу или на этапе commit-а транзакции.
 - Если removed, то переходит в состояние managed. (но только в рамках одной транзакции).'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Как влияет операция persist на Entity объекты каждого из четырех статусов?', 19);

INSERT INTO answers_hibernate (answer) VALUES (
'new > операция игнорируется. // но зависимые Entity могут поменять статус на removed, при условии что
 у них есть аннотации каскадных изменений и они имели статус managed.
 managed > removed и запись объекта в базе данных будет удалена при commit-е транзакции (также произойдут операции
 remove для всех каскадно зависимых объектов).
 detached > exception сразу или на этапе commit-а транзакции.
 removed > операция игнорируется.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Как влияет операция remove на Entity объекты каждого из четырех статусов?', 20);

INSERT INTO answers_hibernate (answer) VALUES (
'Из состояния new перейдет в состояние managed. Будет создана новая сущность.
 // в которую будут скопированы данные прошлого объекта.
 - Для managed будет игнор.
 - Для detached - тоже переводит в managed.
 - А в removed будет исключение. (сразу или на этапе commit-а транзакции).'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Как влияет операция merge на Entity объекты каждого из четырех статусов?', 21);

INSERT INTO answers_hibernate (answer) VALUES (
'Когда managed, то данные нашего Entity обновятся из базы данных.
 // также произойдет refresh всех каскадно зависимых объектов.
 - А во всех остальных состояниях (new, removed, detached) > вылетит exception.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Как влияет операция refresh на Entity объекты каждого из четырех статусов?', 22);

INSERT INTO answers_hibernate (answer) VALUES (
'Если managed, или removed > то будет detached.
 - А если new и detached > то операция игнорируется. '
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Как влияет операция detach на Entity объекты каждого из четырех статусов?', 23);

INSERT INTO answers_hibernate (answer) VALUES (
'Эта аннотация обозначает простейший тип маппинга. И поддерживает два параметра.
 - Optional - это который говорит о том - может ли поле содержать Null или не может.
 - И другой параметр Fetch - там задается, как будут извлекаться данные, ну там жадная загрузка или ленивая загрузка.
 И по умолчанию включена жадная загрузка и допускается Null.
 = А какие типы вообще могут быть помечены в Basic?
 - Это применяется к полям-примитивам, к их оберткам, BigDecimal, BigInteger, строки. И классы даты и времени.
 Также byte[], char[]
 - - - - - - - - -- - - - - - - - - - - -- -- - - - - -- - - - - - - - - - - - -
 - @Basic - указывает на простейший тип данных, который будет мапиться в таблицу.
 Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет.
 Может быть применена к полю любого из следующих типов:
 - Примитивы и их обертки,
 String, BigInteger, BigDecimal, Date, Calendar, Date, Time, Timestamp, byte[] или Byte[], char[] или Character[], Enumы
 и любые другие типы, которые реализуют Serializable.
 Вообще, аннотацию @Basic можно не ставить, как это и происходит по умолчанию.
 Аннотация @Basic имеет 2 атрибута:
 1. Оptional - boolean (по умолчанию true) - определяет, может ли значение поля или свойства быть null.
 // Для примитивных типов игнорируется. Но если тип поля не примитивного типа, то при попытке сохранения сущности будет
 выброшено исключение.
 2. FetchType (по умолчанию EAGER) - определяет, должен ли этот атрибут извлекаться сразу же (EAGER) или лениво (LAZY).
 Однако, это необязательное требование.
 // Без аннотации @Basic при получении сущности из БД по умолчанию её поля базового типа загружаются по EAGER и
 значения этих полей могут быть null.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Для чего нужна аннотация Basic?', 24);

INSERT INTO answers_hibernate (answer) VALUES (
'Эта аннотация связывает поле сущности с колонкой в БД. И вместе с этой аннотацией могут задаваться
ограничения с которыми данные записываются в эту колонку
Т.е. то что - уникальное значение должно быть, не должно быть, Null, длина может задаваться.
= А основное отличие @Basic от @Column какое у нас?
- @Column - относится к столбцу в БД. А @Basic он относится к сущности в JPA.
- - - - -- -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -- - - -
- @Column указывает что поле класса будет столбцом таблицы, а её атрибуты определяют поведение в этом столбце,
используется для генерации схемы базы данных.
В чем разница? @Basic vs @Column:
Если коротко, то в Column (колум) мы задаем constraints (ограничения), а в Basic (бейсик) - FetchType.
1. Атрибуты @Basic применяются к сущностям JPA, тогда как атрибуты @Column применяются к столбцам базы данных.
2. @Basic имеет атрибут optional, который говорит о том, может ли поле объекта быть null или нет;
а @Column имеет атрибут nullable который указывает, может ли соответствующий столбец в таблице быть null или нет?
3. Мы можем использовать @Basic, чтобы указать, что поле должно быть загружено лениво.
4. Аннотация @Column позволяет нам указать имя столбца в таблице и ряд других свойств:
 a. insertable/updatable - можно ли добавлять/изменять данные в колонке, по умолчанию true;
 b. length - длина, для строковых типов данных, по умолчанию 255.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Для чего нужна аннотация Column?', 25);

INSERT INTO answers_hibernate (answer) VALUES (
'Аннотация @Access - определяет доступ к атрибутам сущности. И доступ может быть как к полям, так и
к свойствам. Т.е. либо FIELD либо PROPERTY.
Значит, самый простой способ - в общем Access определяет, т.е. доступ определяется по тому где указана аннотация,
т.е. если аннотация указана над полем, то значит доступ будет непосредственно к полю - это тип FIELD.
А если аннотация указана у геттера, то значит будет доступ к PROPERTYES.
А если мы не указываем аннотацию @Access, то Хибер определит доступ по ID-шнику. Т.е. он посмотрит над каким полем,
либо методом стоит аннотация @ID.
И исходя из этого уже определит тип доступа.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -- - - - - - - - - - -
- Она определяет тип доступа для класса entity, (Mapped)суперкласса, embeddable и их атрибутам,
а именно - как JPA будет обращаться к атрибутам entity: как к полям класса или как к свойствам класса, которые
имеют гетеры и сетеры.
Короче - определяет тип доступа к полям сущности.
Для чтения и записи этих полей есть два подхода:
1. Field access (доступ по полям). При таком способе аннотации маппинга (Id, Column,...) размещаются прямо над полями,
и Hibernate напрямую работает с полями сущности, читает их и записывает их.
2. Property access (доступ по свойствам). При таком способе аннотации размещаются над методами-геттерами,
но никак не над сеттерами.
- По умолчанию тип доступа определяется местом, в котором находится аннотация @Id.
Если она будет над полем - это будет AccessType.FIELD, если над геттером - это AccessType.PROPERTY.
Чтобы явно определить тип доступа у сущности, нужно использовать аннотацию @Access, которая может быть указана у сущности,
Mapped Superclassа или Embeddable classа, а также над полями или методами.
Поля, унаследованные от суперкласса, имеют тип доступа этого суперкласса.
Когда у одной сущности определены разные типы доступа, то нужно использовать аннотацию @Transient для избежания
дублирования маппинга.
И еще: есть одно условие для свойств: методы getFirstName и setFirstName для чтения и записи должны иметь такие же
имена как у поля в БД.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Для чего нужна аннотация Access?', 26);

INSERT INTO answers_hibernate (answer) VALUES (
'Кэширование технология (предоставляемая ORM фреймворками), которая помогает достичь высокую скорость.
Благодаря кэшированию - в базу данных приходится делать меньше запросов, благодаря чему и обеспечивается высокая скорость.
По умолчанию включен кэш первого уровня.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- @Cacheable - это для работы с кэшем второго уровня.
Аннотация размещеется над классом сущности. Ну эта аннотация говорит, должна ли сущность храниться в кэше второго
уровня или нет. И там есть пять уровней:
- ALL - это - все сущности кэшируются.
- NONE - не кэшируется ни одна.
- ENABLE_SELECTIVE - это значит, разрешает кэшироваться, те которые, сущности которые помечены.
- DISABLE_SELECTIVE - кэширует все кроме тех которые помечены как некэшируемые @Cacheable(value=false).
- И еще есть UNSPECIFIED - там помоему как-то по умолчанию начинает работать. Там подразумевает что передает под
управление Хиберу, по умолчанию.
А так как у нас Хибер по умолчанию не имеет своей реализации кэша второго уровня, то это равносильно тому что
кэш второго уровня отключен.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- @Cacheable - необязательная аннотация JPA, используется для указания того, должна ли сущность храниться в кэше
второго уровня или нет.
В JPA есть всего пять значений, которые определяют как будет использоваться этот second-level cache:
? ENABLE_SELECTIVE: означает что сущности с аннотацией @Cacheable будут сохраняться в кэше второго уровня.
(значению по умолчанию @Cacheable(value=true))
? DISABLE_SELECTIVE: в кэше второго уровня, будут сохраняться все сущности, кроме тех что помечены как не кэшируемые
@Cacheable(value=false).
? ALL: сущности всегда кэшируются, даже если они помечены как некэшируемые.
? NONE: ни одна сущность не кэшируется, даже если помечена как кэшируемая.
? UNSPECIFIED: для кэша второго уровня применяются значения по умолчанию.
Аннотацию @Cacheable ставят над классом сущности. Её действие распространяется на эту сущность и её наследников.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Для чего нужна аннотация Cacheable?', 27);

INSERT INTO answers_hibernate (answer) VALUES (
'@Embeddable - размещается над классом для указания того, что класс является встраиваемым в другие классы,
то есть поля этого Embeddeble класса будут добавляться к полям других сущностей и будут представлять столбцы
в таблице этой сущности.
Встраиваемый класс сам не является сущностью.
@Embedded Аннотация - размещается над полем в классе-сущности и указывает на то - что мы внедряем
встраиваемый(Embeddable) класс.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Для чего нужны аннотации @Embedded и @Embeddable?', 28);

INSERT INTO answers_hibernate (answer) VALUES (
'Составной (первичный) ключ, это комбинация из двух или более столбцов для формирования первичного
ключа таблицы.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- Он мапится с аннотацией @IdClass или @EmbeddedID.
Поля составного ключа описываются в отдельном классе. И в первом варианте мы над классом сущности пишем @IdClass,
и имя составного ключа, ну вот указываем класс где описан составной ключ, и внутри сущности объявляем поля.
Вот допустим мы оба поля объявляем, и над ними пишем идентификатор т.е. аннотацию @Id.
Это был первый вариант.
А во втором варианте - класс составного ключа аннотируется @Embeddable. А в классе-сущности над полем класса-ключа
пишем @EmbeddedId.
= А основное отличие какое у них?
- То что, когда мы пишем через @IdClass, то внутри сущности пишем поля, которые являются ключами, ну которые
частями ключей являются.
- А во втором случае мы просто объявляем поле, которое имеет тип вот того класса составного ключа.
Т.е. у нас появляется только одно поле, а не все поля
IdClassa. // Ну и запросы IdClassa - они проще, но при этом EmbeddableId более информативен, хотя является более сложным.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- У нас есть два способа: 1) - Использовать аннотацию @IdClass и 2) - аннотацию @EmbeddedId.
- Пример с @IdClass.
Допустим, у нас есть таблица с именем Account, и она имеет два столбца - accountNumber и accountType, вот они
и будут формировать составной ключ.
Чтобы обозначить оба этих поля как части составного ключа мы должны создать класс, например, ComplexKey с этими полями.
Затем нам нужно аннотировать сущность Account аннотацией @IdClass(ComplexKey.class).
И также нужно объявить поля из класса ComplexKey в сущности Account с такими же именами и аннотировать их с помощью @Id.
public class ComplexKey implements Serializable {
// Создаем класс, поля которого будут являться частями составного ключа. Делаем его Serializable.
private String accountNumber;
// В этом классе создаем два поля.
private String accountType;
// default constructor
public ComplexKey(String accountNumber, String accountType) {
// Инициализируем эти поля через конструктор.
this.accountNumber = accountNumber;
this.accountType = accountType;
// equals() and hashCode()
}
@Entity
@IdClass(ComplexKey.class)            // Создаем второй класс и помечаем его аннотацией @IdClass(ComplexKey.class)
public class Account {
@Id
private String accountNumber;
@Id
private String accountType;
// other fields, getters and setters
}    // Все, у нас теперь есть класс, в котором два поля являются частями составного ключа.
Пример с @EmbeddedId.
В этом случае класс первичного ключа, BookId, должен быть аннотирован @Embeddable.
Затем нам нужно встроить этот класс в сущность Book, используя @EmbeddedId.
@Embeddable
public class BookId implements Serializable {
// Создаем Embedable класс, делаем его Serializable.
private String title;
// Создаем поля, которые будут являться частями составного ключа.
private String language;
// default constructor
public BookId(String title, String language) {
// Инициализируем эти поля через конструктор.
this.title = title;
this.language = language;
// getters, equals() and hashCode() methods
}
@Entity
public class Book {
// Создаем наш Entity-класс.
@EmbeddedId
private BookId bookId;
// Запихиваем в него класс составного ключа. И помечаем это поле аннотацией @EmbeddedID.
// constructors, other fields, getters and setters
}'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Как смапить составной ключ?', 29);

INSERT INTO answers_hibernate (answer) VALUES (
'Аннотация @Id - определяет первичный ключ, состоящий из одного поля.
- А @GeneratedValue - это аннотация которая определяет каким образом формируется значение ключа.
* Значит, по умолчанию используется значение AUTO. И в таком случае - выбор стратегии зависит от типа базы
данных (От ее типа, и диалекта).
* Потом следующий вариант - это IDENTITY. Здесь Id-ключ формируется на стороне БД.
* Потом SEQUENCE - это... в базе данных, ну что-то типа функции есть (SEQUENCE). И она формирует ключ.
* Потом TABLE - это создается в БД специальная таблица, в которой есть колонка, в соответствии с которой
генерируется его ключ.
= А какая разница между SEQUENCE и IDENTITY?
- IDENTITY, я так понимаю что там просто на единицу увеличивается, и все.
- А с помощью SEQUENCE или TABLE - там какие-то вычисления производятся. Ну то есть там, увеличивается не на единицу,
а в соответствии с какой-то функцией.
В TABLE - эту функцию задает программист. Т.е. там специальная таблица создается, в которой есть колонка.
Первичный ключ в соответствии с этой колонкой формируется. А в SEQUENCE - я точно там не скажу...
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- Если мы хотим, чтобы значение первичного ключа генерировалось для нас автоматически, мы можем добавить первичному ключу,
который уже отмечен аннотацией @Id, аннотацию @GeneratedValue.
В параметрах @GeneratedValue мы можем указать одну из 4-рех стратегий:
AUTO(default) - Указывает, что Hibernate должен выбирает нужную стратегию для конкретной базы данных - автоматически.
Смотря какой диалект у БД.
IDENTITY - У него там есть встроенный АВТО-Инкремент, который срабатывает на стороне БД.
SEQUENCE - У него там тоже есть встроенный АВТО-Инкремент на стороне БД.. Но если эта БД не поддерживает тип SEQUENCE,
то Hibernate автоматически переключается на тип TABLE. SEQUENCE намного более гибкий, чем IDENTITY.
TABLE - как я понял, хранит ID-шники (для любого количества сущностей) в отдельной таблице.
И в этой таблице указываются связи.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?', 30);

INSERT INTO answers_hibernate (answer) VALUES (
'Аннотация @JoinColumn - указывает на Foreign Key. Т.е эта аннотация содержит столбец с внешним ключом.
(А на владельца связи указывает параметр mappedBy).
- А @JoinTable - эта аннотация описывает связующую таблицу в отношениях @ManyToMany. Т.е. 3-я связывающая таблица.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- @JoinColumn - указывает что этот столбец FOREIGN KEY, и устанавливает связи между сущностями или коллекциями.
А у нас - кто имеет FOREIGN KEY - тот является владельцем связи. Но также мы можем указать @JoinColumn в обоих таблицах.
Тогда оба будут владельцами связи.
И тогда уже, чтобы точно определить владельца связи - нужно указать атрибут mapppedBy (в @ManyToMany и других).
Примеры:
@OneToOne: - появится столбец в таблице владельца связи, у которого будет внешний ключ.
@OneToMany/@ManyToOne: если у владельца связи не указать атрибут mappedBy, то создается joinTable (отдельная табица)
с ключами обеих таблиц.
@JoinTable - создает связывающую (третью) таблицу между двумя другими таблицами.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?', 31);

INSERT INTO answers_hibernate (answer) VALUES (
'@OrderBy указывает порядок по которому будут извлекаться элементы коллекций сущностей
(базовых или встраиваемых типов) из БД.
Эта аннотация может использоваться с аннотациями @ElementCollection, @OneToMany, @ManyToMany.
@OrderColumn создает в таблице столбец с индексами для поддержания порядка в списке элементов.
но этот столбец не считается частью состояния сущности или встраиваемого класса.
Hibernate отвечает за поддержание порядка как в базе данных при помощи столбца, так и при получении сущностей
и элементов из БД.
Разница между: @OrderBy vs @OrderColumn.
Порядок, указанный в @OrderBy, применяется только в рантайме при выполнении запроса к БД, То есть в контексте
персистентности.
А при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и поддерживается при каждой
вставке/обновлении/удалении элементов.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?', 32);

INSERT INTO answers_hibernate (answer) VALUES (
'Эта аннотация используется, для того чтобы пометить поле, которое не нужно мапить в базу данных.
Также по умолчанию транзиентными полями являются final и static - поля.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- @Transient используется для объявления того, какие поля у сущности, встраиваемого класса или Mapped SuperClass
не будут сохранены в базе данных.
Persistent fields (постоянные поля) - это поля, значения которых будут по умолчанию сохранены в БД. Ими являются
любые не static и не final поля.
Transient fields (временные поля):
Поля - помеченные аннотацией @Transient, статические поля и final поля.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Для чего нужна аннотация Transient?', 33);

INSERT INTO answers_hibernate (answer) VALUES (
'Во первых блокировки делятся на две условные группы: оптимистичные и пессимистичные.
* Оптимистичные - это блокировки на уровне сущности (как я понял). По полю @Version. Т.е. если значение поля
совпадает со значением в базе данных, то
данные сбрасываются в БД и значение @Version увеличивается на единицу. А если мы начинаем сбрасывать данные,
и значение @Version отличается, то тогда будет выброшено исключение.
Поле версии создается в момент, когда он считывает информацию из БД. И когда он пытается выполнить коммит,
он сначала проверяет, как раз этот Version,
если Version не соответствует тому значению которое он имеет в себе, то он - изменения в БД вносить не будет,
транзакция выполняться не будет.
Вот это и подразумевает версионность.
* А пессимистическая блокировка, это блокировка на уровне базы данных.
Когда одна транзакция получила доступ к данным, то доступ для остальных транзакций блокируется.
Различия оптимистичной и писсимистичной блокировки:
- Когда у нас в БД обращение к одним и тем же данным, с разных транзакций (параллельных) происходит редко - тогда
у нас оптимистическая блокировка применяется (и она быстрее чем пессимистичная). Она работает на уровне JPA.
- А пессимистичная - работает на уровне БД, и включаем мы ее, когда происходит, так сказать, борьба за данные из
разных парралельных транзакций.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- В порядке от самого ненадежного и быстрого, до самого надежного и медленного:
1. NONE — без блокировки.
2. OPTIMISTIC (синоним READ в JPA 1) — оптимистическая  блокировка. Это значит что: если при завершении транзакции
кто-то извне изменит поле @Version, то будет сделан RollBack транзакции и будет выброшено OptimisticLockException.
3. OPTIMISTIC_FORCE_INCREMENT (синоним WRITE в JPA 1) — работает так же как и OPTIMISTIC, но только после каждого
commitа значение поле Version принудительно инкрементируется.
4. PESSIMISTIC_READ — данные блокируются в момент чтения и пока выполняется транзакция, никто не сможет их изменить.
Остальные транзакции, тем не менее, смогут параллельно читать эти данные.
5. PESSIMISTIC_WRITE — данные блокируются в момент записи и и пока выполняется транзакция, данные в этой транзакции
никто не сможет ни читать ни писать.
6. PESSIMISTIC_FORCE_INCREMENT — то же самое что и PESSIMISTIC_WRITE, но в конце транзакции значение поля @Version
инкрементируется.
// Аннотация @Version отвечает за блокировки в JPA. Она решает проблемы, которые могут возникнуть при параллельном
выполнении транзакций.
Если у нас какие-то параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным то можно
использовать оптимистическое блокирование.
Но при окончании транзакции будет проверка, изменились ли данные в ходе выполнения этой транзакции и, если да,
то выбросится OptimisticLockException.
Если у нас какие-то параллельно выполняющиеся транзакции очень часто обращаются к одним и тем же данным,
и тем самым конкурируют между собой, то тогда лучше использовать пессимистическое блокирование.
Т.е. блокировать доступ к этим данным.
Блокировки ставятся через метод lock() у EntityManager, в который передаётся сущность, требующая блокировки
и уровень блокировки:
Например:
EntityManager em = entityManagerFactory.createEntityManager();
em.lock(company1, LockModeType.OPTIMISTIC);'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Какие шесть видов блокировок (lock) описаны в спецификации JPA
                                                               (или какие есть значения у enum LockModeType в JPA)?', 34);

INSERT INTO answers_hibernate (answer) VALUES (
'Кэширование технология (предоставляемая ORM фреймворками), которая помогает достичь высокую скорость.
Благодаря кэшированию - в базу данных приходится делать меньше запросов, благодаря чему и обеспечивается высокая скорость.
По умолчанию включен кэш первого уровня.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- Кэш первого уровня - он всегда включен, связан с сессией, и сессия видит только свои объекты. При первом запросе,
там уходит запрос к базе данных, и данные сохраняются в кэше первого уровня. Все последующие запросы получают
данные уже из этого кэша. Кэш первого уровня всегда включен и отключить его мы не можем.
И есть методы для удаления сущностей из кэша и методы для очистки этого кэша.
- А кэш второго уровня, его работа настраивается, и зависит от провайдера, к которому мы подключены
(для управления кэшем второго уровня).
//Чтобы заработал кэш второго уровня, нужно:
//- Определить провайдера, который реализует работу нашего кэша второго уровня. То есть:
//Перед включением провайдера надо сначала подключить Maven-зависимость, и в конфигурации указать провайдера.
Затем нужно, в каком-то классе, реализовать //интерфейс RegionFactory.
//И у нужной сущности указать аннотацию @Cashable, сущность которую нужно кэшировать.
//И прописываем аннотацию @Cache, где указываем детали кэширования. А в деталях прописывается стратегия параллельного
доступа, вот что-то я их не вспомню.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1. Кэш первого уровня (first-level cache) — кэширует данные только одной транзакции;
2. Кэш второго уровня (second-level cache) — кэширует данные всех транзакций, которые были созданы в какой-то
одной фабрики сессий.
// Провайдер JPA может, но не обязан реализовывать работу с кэшем второго уровня.
// Кэш первого уровня – это кэш сессии (Session), который является обязательным, это и есть PersistenceContext.
Через него проходят все запросы.
// Если мы закроем сессию, то все объекты, находящиеся в кэше, теряются. а потом – либо сохраняются в БД,
либо обновляются.
Особенности кэша первого уровня:
- включен по умолчанию, его нельзя отключить;
- связан с сессией (контекстом персистентности). Разные сессии видят только объекты из своего кэша, и не видят объекты,
находящиеся в кэшах других сессий;
- при закрытии сессии PersistenceContext очищается - кэшированные объекты, находившиеся в нем, удаляются;
- при первом запросе сущности из БД, она загружается в кэш, связанный с этой сессией;
- если в рамках этой же сессии мы снова запросим эту же сущность из БД, то она будет загружена из кэша,
и никакого второго SQL-запроса в БД сделано не будет;
- сущность можно удалить из кэша сессии методом evict(), и тогда, чтобы снова получить эту же сущность,
придется опять делать запрос в базу данных;
- метод clear() очищает весь кэш сессии.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?', 35);

INSERT INTO answers_hibernate (answer) VALUES (
'Чтобы заработал кэш второго уровня, нужно:
- Определить провайдера, который реализует работу нашего кэша второго уровня. То есть:
Перед включением провайдера надо сначала подключить Maven-зависимость, и в конфигурации указать провайдера.
Затем нужно, в каком-то классе, реализовать интерфейс RegionFactory.
И у нужной сущности указать аннотацию @Cashable, сущность которую нужно кэшировать.
И прописываем аннотацию @Cache, где указываем детали кэширования. А в деталях прописывается стратегия параллельного
доступа, вот что-то я их не вспомню.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня.
Чтобы создать кэш второго уровня - (в Hibernate) кэширование второго уровня нужно настроить RegionFactory (интерфейс).
(Кэш 2 уровня разбит на регионы).
RegionFactory это - как мост между Hibernate и поставщиками кэша.
Сам Hibernate не предоставляет кэш, но у него есть другие поставщики. Вот несколько провайдеров:
Поставщиики кэша: Ehcache, OSCache, SwarmCache, JBoss TreeCache.
В примерах будем использовать Ehcache. Что нужно сделать:
- добавить мавен-зависимость кэш-провайдера нужной версии.
- включить кэш второго уровня и указать провайдера
hibernate.cache.use_second_level_cache=true;
hibernate.cache.ehcache.EhCacheRegionFactory;
- установить у нужных сущностей JPA-аннотацию @Cacheable, обозначающую, что сущность нужно кэшировать, и
Hibernate-аннотацию @Cache.
В качестве параметра, в этих аннотациях нужно указать стратегию параллельного доступа.
Стратегии параллельного доступа к объектам:
- READ_ONLY: Используется только для сущностей, которые никогда не изменяются (если попытаться изменить эту сущность,
будет выброшено исключение).
- NONSTRICT_READ_WRITE: Кэш обновляется после совершения транзакции, которая изменила данные в БД и закоммитила их.
- READ_WRITE: Здесь при обновлении сущности, на нее накладывается мягкая блокировка, которая снимается после
коммита транзакции. Все параллельные транзакции, которые пытаются получить доступ к записям в кэше с мягкой блокировкой,
не смогут их прочитать или записать и отправят запрос в БД.
Ehcache использует эту стратегию по умолчанию.
- TRANSACTIONAL: Здесь идет разделение транзакций. Каждая сессия и каждая транзакция работают по отдельности, последовательно.
Но при этом падает производительность.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Как работать с кешем 2 уровня?', 36);

INSERT INTO answers_hibernate (answer) VALUES (
'HQL и JPQL - это объектно-ориентированные языки запроса, схожие с SQL.
SQL там - обращение идет к колонкам и выбираются строки, а в HQL и JPQL - там работа идет с сущностями.
И объектно-ориентированные языки запросов, они поддерживают полиморфизм.
JPQL - является подмножеством HQL.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- Hibernate Query Language (HQL) и Java Persistence Query Language (JPQL) - оба являются объектно-ориентированными языками запросов.
Я так понимаю что: JPQL - относится к JPA, а HQL - относится к Hibernate.
Они немного похожи на SQL. JPQL - является подмножеством HQL.
JPQL и HQL - они похожи на SQL, только вместо имен и колонок таблиц базы данных, они используют имена классов
Entity и их атрибуты.
В JPQL есть автоматический полиморфизм, и каждый запрос к Entity возвращает не только объекты этого Entity,
но и объекты всех его классов-потомков.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Что такое JPQL/HQL и чем он отличается от SQL?', 37);

INSERT INTO answers_hibernate (answer) VALUES (
'Criteria API - это API используемое для выборки данных в объектно-ориентированном стиле.
Т.е. это аналог команды Select.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- В Hibernate, (начиная с версии 5.2) Hibernate Criteria API объявлен deprecated.
 Вместо него рекомендуется использовать JPA Criteria API.
JPA Criteria API - это такой аналог команды SELECT в SQL, используется для выборки сущностей из БД
в объектно-ориентированном стиле.
Основные преимущества JPA Criteria API:
- ошибки могут быть обнаружены во время компиляции;
- также с помощью него можно запросы можно формировать динамически, на этапе выполнения приложения.
Основные недостатки:
- нет контроля над запросом, и поэтому сложно отловить ошибку в рантайме.
- из-за множества классов, внутри него, немного падает производительность.
Области применения Criteria API:
- Использование агрегатных функций вроде sum(), min(), max() и т.д.
- Извлечение данных из выбранных колонок.
- Организация join-запросов, с помощью которых можно соединять несколько таблиц. Для этого есть методы:
createAlias(), setFetchMode() и setProjection().
- Сортировку результата выборки, с помощью метода addOrder().'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Что такое Criteria API и для чего он используется?', 38);

INSERT INTO answers_hibernate (answer) VALUES (
'Проблема N+1 возникает при получении из базы данных, когда используется N - дополнительных запросов,
хотя их можно было получить в одном запросе.
И решается такая проблема несколькими способами:
1. Используется JOIN FETCH, в объектно-ориентированных языках запросов.
2. Через аннотацию @Fetch - задается параметр SUBSELECT - ленивая инициализация. В этом варианте будут два запроса.
Первый запрос получит основную сущность,
а второй запрос - все связанные объекты с ней.
3. @BatchSize(size=5)
- он задает количество коллекций которое нужно загрузить. Т. е. если нам нужно получить 6 коллекций,
а мы задали @BatcSize = 2, то будет сделано 3 запроса.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- Проблема N+1 запросов возникает, когда получение данных из БД выполняется за N дополнительных SQL-запросов,
хотя эти данные можно было получить одним основным запросом.
Проблема может быть решена следующими способами:
1. JOIN FETCH.
// И при FetchType.EAGER и при FetchType.LAZY нам поможет JPQL-запрос с JOIN FETCH. Опцию «FETCH» можно использовать
в JOIN (INNER JOIN или LEFT JOIN) для // выборки связанных объектов в одном запросе вместо дополнительных запросов
для каждого доступа к ленивым полям объекта.
// Лучший вариант решения для простых запросов (1-3 уровня вложенности связанных объектов).
Например пишем JPQL:
select pc
from PostComment pc
join fetch pc.post p.
2. EntityGraph.
Используется, когда надо получить очень много данных, и у нас jpql запрос. Тогда лучше использовать EntityGraph.
3. @Fetch(FetchMode.SUBSELECT).
Это такая аннотация Hibernate. Она используется только с коллекциями. Будет сделан только один sql-запрос для
получения корневых сущностей.
И по мере необходимости, могут быть выполнены еще запросы, но будут выполнены лениво.
@Fetch(value = FetchMode.SUBSELECT)
// Короче я не понял.
4. Batch fetching.
Это Аннотация Hibernate, в JPA её нет.
Указывается над классом сущности или над полем коллекции с ленивой загрузкой. Будет сделан один sql-запрос для
получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям,
то выполнится еще один запрос для получения связанных коллекций.
Здесь количество загружаемых сущностей указывается в аннотации.
@BatchSize(size=5)
private Set<Order> orders = new HashSet<>();
5. HibernateSpecificMapping, SqlResultSetMapping.
Для нативных запросов рекомендуется использовать именно их.
/////////////////////////////////////////////////////////////
- Для борьбы с проблемой N+1 можно использовать аннотацию @BatchSize(size = 2), поместив ее над полем связанной сущности.
- Можно извлечь все необходимые данные одним SQL-запросом, используя ключ. слово JOIN FETCH.
- Можно использовать FetchType.LAZY вместо FetchType.EAGER. (Помогает не всегда).'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Расскажите про проблему N+1 Select и путях ее решения.', 39);

INSERT INTO answers_hibernate (answer) VALUES (
'Он используется - когда очень много данных. И по сути, в EntityGraf мы можем прописать столбцы,
которые нам необходимы в работе. Т.е. мы создаем объект на основании этих графов. Т.е. не весь объект загружаем,
а например таблица имеет 20 столбцов, а в работе нам надо только 2 столбца, и мы как раз через EntityGraf указываем
эти два столбца. Т.е. указать графы, которые надо загружать. При этом мы можем в качестве графа указать
взаимосвязанные сущности, и мы можем ограничить, т.е. например не полностью сущность загружать, а загрузить
какую-то определенную информацию этой сущности.
Т.е. допускается частичная загрузка сущности, не полностью от и до, а только то что нам нужнов работе.
(и поля сущности мы тоже можем ограничить).
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- EntityGraph - это такой способ решения проблем с производительностью при загрузке данных из БД, который был
введен в JPA 2.1.
Он позволяет выбирать тип графа во время выполнения программы.
Также я где-то читал что, с помощью Entity Graph можно менять стратегию FetchType.EAGER или FetchType.LAZY
во время выполнения программы.
Таким образом улучшается производительность в рантайме при загрузке базовых полей сущности, связанных сущностей,
и коллекций.
Т.е. получается - Hibernate загружает весь граф в одном SELECT-запросе. Загружает все указанные связи от нужной
нам сущности.'
);
INSERT INTO questions_hibernate (question, answer_id) VALUES ('Что такое EntityGraph? Как и для чего их использовать?', 40);


-- src/main/resources/db/db.db.migration/V3__insert_spring.sql
-- SPRING
INSERT INTO answers_spring (answer) VALUES (
'- Inversion of Control - это такой подход ООП, который позволяет передать контроль над созданием и управлением
объектами (в Java) другому фреймворку, например Spring-у. Этот механизм Inversion of Control работает с помощью
рефлексии.
Вместо ручного создания объектов и управление ими, и внедрения зависимостей в эти объекты, можно все это дело
передать фреймворку.
А он уже возьмет на себя всю
ответственность за создание и управление этими объектами (благодаря Inversion of Control-контейнеру).
Контейнер (или по другому, контекст) отвечает за управление жизненным циклом объекта: т.е. - создание объектов,
вызов методов инициализации и
связывания этих объектов  между собой.
Объекты, создаваемые контейнером, называются БИНами. Конфигурирация контейнера с этими бинами осуществляется с
помощью аннотаций (это современный способ), но также можно конфигурировать контейнер с помощью XML-файлов
(это уже по старинке).
- Dependency Injection — это одна из реализации принципа Inversion of Control (в Spring). Это такой шаблон
проектирования, в котором контейнер внедряет одни
объекты в другие объекты. Он может внедрять: при помощи конструктора или метода-setter-а. И это позволяет
снизить связанность между компонентами, т.е. объектами, а так же повысить модульность и расширяемость ПО.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Что такое инверсия контроля (IoC) и внедрение зависимостей (DI)? Как эти принципы реализованы в Spring?', 1);

INSERT INTO answers_spring (answer) VALUES (
'- Inversion of Control Container (в Spring-е) - это такой контейнер, его еще называют контекст.
Он отвечает за создание, настройку и сборку объектов, которые называются БИНы, а также отвечает за управление
этими бинами и их жизненным циклом.
Чтобы создать контейнер Spring - нужно создать объект контейнера на основе интерфейса ApplicationContext и его
классов, которые его реализуют.
Существует несколько реализаций интерфейса ApplicationContext:
? ClassPathXmlApplicationContext и FileSystemXmlApplicationContext - это для автономных приложений.
(Здесь используются файлы XML);
- FileSystemXMLApplicationContext - здесь контекст загружается из файла.
- ClassPathXmlApplicationContext - здесь контекст загружается из пути компьютера. Можно несколько файлов
конфигурации указывать через запятую.
? WebApplicationContext - это идет для веб-приложений;
? AnnotationConfigApplicationContext - здесь конфигурация происходит с помощью аннотаций.
И в конструктор нужно передать либо пакет - где находится конфигурационный класс, помеченный аннотацией
@Configuration, либо сам этот конфигурационный класс.
Получается, - Spring-контейнер читает все записи конфигурационного класса и все другие аннотации,
ну т.е. получает инструкции о том, какие объекты нужно создавать и настраивать. А эти все конфигурации могут
быть представлены в виде XML-файла, Java-аннотаций или Java-кода:
? XML - Метаданные считываются из файла с расширением *.xml;
? Java-аннотации - это когда метаданные конфигурации считываются на основе аннотаций. Но также есть один XML-файл
с базовыми настройками.
Аннотации могут использоваться в классах, методах и полях.
Контейнер сначала читает аннотации, а уже потом файл-XML, поэтому, если бин конфигурируется и через аннотации и
через XML-файл, то настройки XML в итоге переопределят настройки аннотаций.
? Java-код - Здесь используется чисто Java-код и аннотации. Файлов XML тут нет вообще. А настройки определяются
в специальном классе, помеченном аннотацией @Configuration. (Java-код с аннотациями появились - начиная со Spring 3.0).'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Что такое IoC контейнер?', 2);

INSERT INTO answers_spring (answer) VALUES (
'Бины - это объекты, созданные и управляемые контейнером Spring. Это такой же обычный объект ООП, но только
он был создан Spring-ом и находится в его контексте (или контейнере).
// Бины и их зависимости обычно прописываются в конфигурации, или же могут быть помечены аннотацией @Component.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Что такое Bean в спринге?', 3);

INSERT INTO answers_spring (answer) VALUES (
'Аннотация @Bean указывает на метод, который создает, настраивает и инициализирует новый объект, т.е. бин,
который находится в контейнере и управляется им.
Эти методы можно использовать в классах с аннотацией @Configuration, а также можно и в классах с аннотацией
@Component(или её наследниках). //Проверено мной.
// Классы, аннотированные @Configuration, проксируются через CGLIB. Классы @Component или обычные классы не проксируются.
@Bean(\"nameGibbon\")
public Gibbon beanGibbon(){
System.out.println(\"Bean created from MyConfig-class\");
        return new Gibbon();
}
По умолчанию именем бина будет являться имя метода, а если мы захотим задать другое имя для бина
(т.е. создать алияс) - то его можно указать в параметрах аннотации @Bean(\"name\").'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про аннотацию @Bean?', 4);

INSERT INTO answers_spring (answer) VALUES (
'@Component - указывает на класс из которого Spring будет создавать бины.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про аннотацию @Component?', 5);

INSERT INTO answers_spring (answer) VALUES (
'@Bean - ставится над методом который создает бины из классов, которые могут находиться в какой-нибудь
сторонней библиотеке (ну или же написанные нами),
а @Component используется для указания класса, чтобы создавать бины, но эти классы могут быть написаны только программистом.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Чем отличаются аннотации @Bean и @Component?', 6);

INSERT INTO answers_spring (answer) VALUES (
'@Service - указывает, что класс является сервисом для реализации бизнес-логики.
Т.е. в этих классах прописывается какая-то бизнес-логика.
@Repository, @Service, @Controller и @Configuration - это алиасы(псевдонимы) @Component, т.е. эти аннотации имеют
ту же функциональность что и @Component.
Технически они одинаковы, но только у них разные названия, и используются для разных целей.
@Repository - указывает, что этот класс используется для работы с поиском, получением или хранением данных.
Также эта анннотация может включать в себя все реализации шаблона DАО (Data Access Object (Объект доступа к данным)).
// DAO - инкапсулирует всю логику работы с БД, а @Repository больше приближен к домену.
Также в задачу @Repository входит отлов определенных исключений персистентности и проброс их дальше,
как непроверенное исключение.
Но для этого - в контейнере должен быть класс PersistenceExceptionTranslationPostProcessor.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про аннотации @Service и @Repository. Чем они отличаются?', 7);

INSERT INTO answers_spring (answer) VALUES (
'@Autowired – внедряет подходящий бин автоматически. Происходит это следующим образом:
1) В первую очередь контейнер определяет тип объекта для внедрения.
2) Затем контейнер подыскивает у себя внутри соответствующий тип бина.
3) Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он.
//Аннотация @Primary задает бин, который будет внедрен по умолчанию.
4) Если используется @Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять,
какой именно компонент внедрять
5) А иначе контейнер внедрит бин, основываясь на его имени или ID. (Например @Component(\"name\")).
6) Если ни один из способов не сработал, то будет выброшено исключение.
И еще в аннотации есть один параметр required(требуется) = true/false - который указывает, обязательно ли
делать DI или нет. По умолчанию true.
Если мы не хотим чтобы было выброшено исключение, то внедряемое поле можно оставить c null, или прописать условие:
если нужный бин не был найден - false.
// Потом - при циклической зависимости, когда объекты ссылаются друг на друга, аннотацию @Autowired ставить
над конструктором нельзя.
// Потом - контейнер внедряет зависимость с помощью класса AutowiredAnnotationBeanPostProcessor.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про аннотацию @Autowired.', 8);

INSERT INTO answers_spring (answer) VALUES (
'Аннотация @Resource позволяет внедрять ресурсы. Она применяется к классам, полям или методам.
// Также как и @Autowired, но разница все-таки есть.
Перед тем как внедрить какую-то зависимость (т.е. ресурс), она сначала ищет его по имени, затем ищет по типу,
затем по описанию (Qualifier).
Имя ресурса берется из имени метода(сеттера) или поля, который мы пометили этой аннотацией, или имя берется из
параметра аннотации @Resourse.
А при аннотировании классов - имя должно быть указано явно.
Когда мы указываем эту аннотацию у полей или методов, с аргументом \"name\", в контейнере будет выполнен поиск
бинов с таким-же именем, и в контейнере должен быть бин с таким именем:
@Resource(name=\"namedFile\")
private File defaultFile;
Если указать аннотацию @Resource без аргументов, то Spring будет искать бин по его типу. Если в контейнере находится
несколько бинов-кандидатов на внедрение, то нужно использовать аннотацию @Qualifier:
@Resource
@Qualifier(\"file_1\")
private File dependency1;
@Resource
@Qualifier(\"file_2\")
private File dependency2;
Разница с @Autowired:
? Аннотация @Resource ищет бин сначала по имени, а потом по типу;
(а @Autowired сначала ищет по типу).
? Аннотации @Resource не нужна дополнительная аннотация для указания имени конкретного бина;
 (потому что у @Autowired, чтобы указать имя, приходится делать так @Qualifie(name)
? Потом аннотация @Autowired позволяет указать, что бин внедрять необязательно @Autowired(required = false);
(а у @Resource такого нет).
? при замене Spring-а на другой фреймворк, менять аннотацию @Resource не нужно. (т.е. другие популярные фреймворки
тоже используют эту аннотацию).'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про аннотацию @Resource.', 9);

INSERT INTO answers_spring (answer) VALUES (
'@Inject - это аннотация Java, является аналогом @Autowired в Spring-е. Она внедряет зависимости, в первую
очередь по типу, затем по описанию и только потом по имени. В ней нет параметров.
И поэтому при использовании конкретного имени (Id) бина используем дополнительную аннотацию @Named. Например пишем:
@Inject
@Named(\"variable\")
private Animal variable;
@Inject не относится к Spring-у, и входит в пакет javax.inject. А чтобы её использовать, надо добавить Maven-зависимость:
<dependency>
<groupId>javax.inject</groupId>
<artifactId>javax.inject</artifactId>
<version>1</version>
</dependency>'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про аннотацию @Inject.', 10);

INSERT INTO answers_spring (answer) VALUES (
'Аннотация @Lookup(поиск) - используется, когда у объекта синглтон, каждый раз меняется
внедряемый объект, который может быть Prototype.
Например:
У нас есть бин Car(автомобиль) – и он синглтон, и ему каждый раз требуется новый экземпляр бина Passenger(пассажир).
То есть Car – синглтон, а Passenger – так называемый
прототипный бин.
И жизненные циклы у этих бинов разные.
Бин Car создается контейнером только один раз, а бин Passenger создается каждый раз новый.
Например это происходит каждый раз при вызове какого-то метода
бина Car. Вот здесь то и пригодится внедрение бина с помощью Lookup метода.
Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод.
Можно создать метод-заглушку в бине Car и пометить его – аннотацией @Lookup.
И этот метод должен возвращать бин Passenger, каждый раз новый.
Даже если в вашей заглушке он возвращает null (а так и надо делать, все равно этот метод будет переопределен).
Пример:
@Component
public class Car {
@Lookup
public Passenger createPassenger() {
       return null;
}
public String drive(String name) {
Passenger passenger = createPassenger();
passenger.setName(name);
return \"car with \" + passenger.getName();
   }
 }'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про аннотацию @Lookup.', 11);

INSERT INTO answers_spring (answer) VALUES (
'Напрямую нельзя. Потому что Spring не позволяет внедрять бины напрямую в статические поля.
Потому что - загрузчик классов загружает статические значения раньще чем, Spring загрузит бины в контекст.
Но это можно исправить. Для этого можно создать нестатический сеттер-метод, и пометить его аннотацией @Autowired:
private static Item item;
@Autowired
public void setItem(Item item) {
TestDataInit.item = item;
// Получается просто внедряем статическое в нестатическое.
}'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Можно ли вставить бин в статическое поле? Почему?', 12);

INSERT INTO answers_spring (answer) VALUES (
'@Qualifier применяется если кандидатов для автоматического связывания несколько. В ее параметрах мы можем
указать имя конкретного бина, который мы собираемся внедрить. Эта аннотация может быть применена к отдельному полю
класса, к отдельному аргументу метода или конструктора. Например:
public class AutowiredClass {
@Autowired //к полям класса
@Qualifier(\"dog\")
private Animal animal;
@Autowired //к отдельному аргументу конструктора или метода
public void voice(@Qualifier(\"dog\") Animal animal){
/* что-то делаем... */
@Primary тоже используется для автоматического внедрения, когда есть несколько бинов одного типа, но только
в ней нельзя задать имя бина, и она определяет значение по умолчанию. Получается что @Qualifier более специфичен.
Если стоят обе эти аннотации, и @Qualifier и @Primary, то аннотация @Qualifier - идет по ПРИОРИТЕТУ выше.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про аннотации @Primary и @Qualifier.', 13);

INSERT INTO answers_spring (answer) VALUES (
'Чтобы заинжектить примитив, надо использовать аннотацию @Value. Ее можно ставить над полем,
конструктором или методом.
Значения этих примитивов можно указывать напрямую, а можно получать из property файлов, или из view,
или из других бинов, и т.п.
Если значения будут указываться из Property-файлов, то нужно указать аннотацию @PropertySource,
перед классом конфигурации.
Пример: @PropertySource(\"classpath:values.properties\")

Пример из файла:
@Value(key)
public String stringValue;

В эту переменную будет внедрена строка, например из property или из view.
// Кроме того, для внедрения значений мы можем использовать язык SpEL (Spring Expression Language).'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Как заинжектить примитив?', 14);

INSERT INTO answers_spring (answer) VALUES (
'Да также как и обычный объект. Можно заинжектить с помощью аннотации @Autowired.
Можно заинжектить: массив, коллекцию, или map-у с дженериком, или другие бины подходящие по типу.
В случае с map ключом будет имя бина.
Пример:
@Autowired
@Qualifier(\"action\")
List<Hero> actionHeroes;
Или в конфигурационном классе, с помощью аннотации @Bean.
@Bean
public ArrayList<Hero> action() {
ArrayList<Hero> result = new ArrayList<>();
result.add(new Terminator());
result.add(new Rambo());
return result;
}
Используя аннотацию @Qualifier можно настроить тип необходимого бина.
Также бины можно упорядочить с помощью аннотации @Order (если, например у нас идут какие-то неупорядоченные
коллекции, вроде Set или Map).'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Как заинжектить коллекцию?', 15);

INSERT INTO answers_spring (answer) VALUES (
'Аннотация @Conditional - она поддерживает настройки компонентов Spring в соответствии с условиями.
То есть - смотря какое условие будет выполнено, так и будет настроен наш бин перед созданием или после.
(После, потому что я где-то читал что их выполнение можно также настраивать в рунтайме).
Например: @Conditional, на основе каких-то определенных условий будет определять, следует ли создавать bean-компонент
в контейнере или нет.
Например я делал так:
@Component(\"name\")
// - Здесь тоже можно ставить эту аннотацию @Conditional(Gibbon.class)
public class Gibbon implements Condition {           // Создаем и мплементим класс от функц. интерфейса Condition.
@Override\n" +
public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { // И у него есть метод matches()
System.out.println(\"matches worked!\");               // где мы и прописываем всю логику создания бина.
return true;                                           // Если метод вернет True, то бин создастся, а иначе нет.
    }
}
@Bean(\"beanGibbon\")
@Conditional(Gibbon.class)       // Затем в конфиг. классе, в методе с @Bean, указываем @Conditional(Gibbon.class)
public Gibbon beanGibbon(){
       return new Gibbon();
   }
Там можно создавать и более сложные условия, используя классы AnyNestedCondition, AllNestedConditions и
NoneNestedConditions. // Но я не пробовал.
То есть - аннотация @Conditional указывает, что БИН будет регистрироваться в контексте только тогда, когда
все условия соответствуют.
Условия проверяются непосредственно перед регистрацией компонента BeanDefinition, и они могут помешать регистрации
данного BeanDefinition.
Поэтому нельзя взаимодействовать с бинами при проверке условий, потому что возможно их еще не существует.
Также, мы можем проверить несколько условий, из нескольких классов. Для этого можно передать в @Conditional
несколько классов с условиями:
@Conditional(Gibbon.class, Elephant.class)
Если класс @Configuration пометить как @Conditional, то на все методы с аннотацией @Bean будут распространяться
указанные условия.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про аннотацию @Conditional.', 16);

INSERT INTO answers_spring (answer) VALUES (
'Профили - позволяют нам разделять все бины на различные логические группы. Например: dev, test, prod.
Например, нашему приложению нужны объекты транспортного средства. В морской среде мы будем создавать лодки,
а в аэрокосмической среде создавать самолеты.
Благодаря аннотации @Profile, можно активировать разные профили в разных средах.
Пример: @Profile(\"dev\"), @Profile(\"!dev\").
Таким образом можно загрузить только те бины, которые нам нужны.
В данном случае она чем-то похожа на @Conditional.
Активировать профили можно в файле properties, можно в командной строке, можно в каком-нибудь веб-модуле.
Также активировать профили можно через: System.setProperty(\"spring.profiles.active\", \"prod\"); // Это я проверял. )
Данную аннотацию можно применять на уровне класса или метода. Т.е. ее можно ставить над классами с аннотацией
@Component или с аннотацией @Configuration.
Потом... аннотация @Profile может принимать в параметры имя одного или нескольких профилей.
// И еще я где-то читал что она реализована с помощью вот этой аннотации @Conditional. '
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про аннотацию @Profile.', 17);

INSERT INTO answers_spring (answer) VALUES (
'BeanFactory(фабрика бинов) — это интерфейс верхнего уровня (в Spring), он предоставляет механизмы конфигурации,
которые управляют объектами любого типа.
// BeanFactory предоставляет всю инфраструктуру конфигурации и основные функциональные возможности.
// По сравнению с ApplicationContext - BeanFactory легче.
ApplicationContext - это наследник BeanFactory и его подчиненный интерфейс. Он полностью реализует его функционал,
добавляя свои специфические функции.
Значит, в чем отличие:
1. Основное отличие в том, что в ApplicationContext все бины создаются сразу при запуске,
а в BeanFactory - только по вызову метода.
// context.getBean(\"name\",Gibbon.class);
2. ApplicationContext поддерживает все scop-ы бинов, а BeanFactory поддерживает только два - Singleton и Prototype.
3. И еще в BeanFactory не работают транзакции и Spring AOP, а в ApplicationContext, получается - работают.
4. Также ApplicationContext предоставляет еще несколько функций:
a. внедряет зависимости на основе аннотаций;
b. предоставляет доступ к MessageSource(источнику сообщений);
c. публикует ApplicationEvent(события) - для бинов, // реализующих интерфейс ApplicationListener
(с помощью интерфейса ApplicationEventPublisher);
d. позволяет интегрировать все функции Spring в Аспектно-ориентированном-программировании (AOP).
5. ApplicationContext поддерживает автоматическую регистрацию BeanPostProcessor и BeanFactoryPostProcessor.
А BeanFactory не поддерживает.
// И поэтому всегда желательно использовать ApplicationContext.
>>> BeanPostProcessor — это интерфейс. Он позволяет настраивать бины прежде чем они попадут в контейнер.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про ApplicationContext и BeanFactory,  чем отличаются? В каких случаях что стоит использовать?', 18);

INSERT INTO answers_spring (answer) VALUES (
'  Жизненный цикл бина — это время существования объекта какого-либо класса. Состоит из следующих этапов:
 -  Инициализация бина и внедрение всех зависимостей.
 -  Если необходимо задать какое-либо действие при инициализации, то можно создать метод init() и пометить аннотацией @PostConstruct.
 -  Создание бина.
 -  Когда бин готов к использованию. Его можно получить с помощью метода getBean() из ApplicationContext.
 -  После того как контекст будет закрыт, методом close(), бин уничтожается. Когда контейнер уничтожается, то всё содержимое тоже уничтожается.
 -  Если необходимо задать какое-либо действие при уничтожении бина, то можно создать метод destroy(). И пометить его аннотацией @PreDestroy.
 -(Во многие процессы жизненного цикла можно вмешаться, добавив туда собственную логику).

 Если подробно:
 1. Сначала создаются описатели бина (BeanDefinition).
 BeanDefinition — это такие объекты, которые содержат в себе всю информацию, так сказать описание будущего бина, по которому нужно будет создавать бин.
 Для каждого бина создается свой объект BeanDefinition. Получается, сколько бинов в программе - столько и объектов BeanDefinition, которые их описывают.
 BeanDefinition может содержать в себе следующие данные (метаданные):
    1. Имя класса с указанием пакета.
    2. Конфигурации бина, которая определяет, как бин должен вести себя в контейнере (scope, аргументы конструктора, ленивая загрузка или жадная,
    и другие там разные свойства.).
    3. Ссылки на другие bean-компоненты, то есть какие у него имеются зависимости.
    4. И другие параметры конфигурации, например такие как: ограничение количества соединений, используемых в бине, если он управляет пулом соединений.

 При конфигурации через аннотации используется класс AnnotationConfigApplicationContext. В параметрах нужно указать пакет сканирования или класс (или классы).

 Все классы сначала регистрируются в конфигурационном классе с аннотацией @Configuration, затем регистрируется специальный BeanFactoryPostProcessor,
 который при помощи класса ConfigurationClassParser парсирует(собирает данные) из конфигурационного класса, загружает описания бинов (BeanDefinition).

 Затем создается хешмапа, в которой будут храниться все BeanDefinition-ы(описания) бинов, которые были обнаружены во время парсинга конфигурации.
 // Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);

 2.
 Теперь, когда есть коллекция Map, в которой хранятся BeanDefinition-ы, все это дело нужно настроить.
 Настройкой BeanDefinition-ов занимаются некие BeanFactoryPostProcessor-ы.

 В интерфейсе BeanFactoryPostProcessor всего один метод:

 public interface BeanFactoryPostProcessor {
 	void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
 }

 Вот в нем мы и прописываем всю настройку.

 // 3. Если конфигурация находится в XML-файле, то создаются кастомные фабрики бинов(FactoryBean).

 4. Затем, после этого, происходит создание самих экземпляров бинов.
 Получается BeanFactory достает всю информацию, о том как создавать бины, из коллекции Map, т.е. достает оттуда все объекты BeanDefinition.
 И на основе этих BeanDefinition-ов  BeanFactory - создает все экземпляры бинов.

 5. После того, как бины созданы, их тоже нужно настроить.
 Настройкой занимается интерфейс BeanPostProcessor. Он настраивает бины еще до того как они попадут в контейнер.
 Т.е. BeanPostProcessor - обрабатывают все... вот эти аннотации: @Autowired, @Inject, @Value и @Resource, и по ним он их и настраивает, как я понял.
 Затем ApplicationContext, он же контейнер, начинает автоматический поиск готовых, настроенных бинов, и помечает их как “post-processors” и все эти бины теперь будут находиться в этом контейнере.

 6. Все. Теперь когда бины готовы к использованию.
 Их можно получить с помощью метода getBean() (из ApplicationContext).

 7. Потом, при закрытии контекста, с помощью метода close() все бины уничтожаются.
 Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод, а в нем срабатывает вся прописанная в нем логика.
 *******************
 Аннотация @PostConstruct - помечает метод, в котором мы можем прописать какую-то логику, сразу после инициализации свойств компонента (бина).
 Такой метод вызывается только один раз, и может иметь любой уровень доступа, может иметь любой тип возвращаемого значения (хотя тип возвращаемого значения игнорируется Spring-ом и тогда лучше использовать void), метод не должен принимать аргументы.
 Он также может быть статическим, только преимуществ такого использования метода нет, т.к. доступ у него будет только к статическим полям/методам бина.
 Метод аннотированный @PostConstruct может использоваться, например, для заполнение базы данных. Срабатывает после конструктора (Я проверял).

 Аннотация @PreDestroy - помечает метод, когда нужно прописать какую-то логику непосредственно перед уничтожением бина.
 Методы, аннотированные @PreDestroy, тоже (как и методы с @PostConstruct) могут иметь любой уровень доступа, но не могут быть статическими.
 Обычно такие методы используются для освобождения каких-то ресурсов или выполнение каких-то других задач, например по очистке таблицы из БД до того как
 бин будет уничтожен. Или например, можно использовать для закрытия соединения с базой данных.

 Аннотации @PostConstruct и @PreDestroy не относятся к Spring-у и находятся в пакете javax.annotation.
 Поэтому, для использования этих аннотаций, нужно добавить дополнительную зависимость:
 <dependency>
 	<groupId>javax.annotation</groupId>
 	<artifactId>javax.annotation-api</artifactId>
 	<version>1.3.2</version>
 </dependency>'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про жизненный цикл бина, аннотации @PostConstruct и @PreDestroy().', 19);

INSERT INTO answers_spring (answer) VALUES (
'- Существует 2 области видимости по умолчанию:
 * Singleton - это область видимости по умолчанию. Это означает, что в контейнере будет создан только один бин, и все запросы на него будут возвращать один и тот же бин. Например, сколько-бы раз мы не вызывали метод getBean(), он все равно будет возвращать один и тот же объект.
 * Prototype - при вызове метода getBean(), при запросе, каждый раз возвращает новый объект.
 У бинов с областью видимости “prototype” метод destroy() не вызывается (так как не берет на себя контроль полного жизненного цикла этого бина).
 Spring не хранит такие бины в своём контексте (контейнере), а отдаёт их клиенту и больше о них не заботится (в отличие от синглтон-бинов).

 И еще есть 4 области видимости в веб-приложении.
 * Request - Область видимости для HTTP-запросов. (один HTTP запрос). Это означает что - на каждый запрос создается новый бин.
 * Session - Область видимости для сессий. (одна сессия). Т.е. на каждую сессию создается новый бин.
 * Application - Область видимости — для жизненного цикла ServletContext.
 * WebSocket - Область видимости — жизненного цикла WebSocket.
 (Жизненный цикл web csope полный).
 //Потом,
 в пятой версии Spring-а не стало области видимости Global-session. А вместо нее появились Application и WebSocket.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про скоупы бинов? Какой скоуп используется по умолчанию? Что изменилось в пятом спринге?', 20);

INSERT INTO answers_spring (answer) VALUES (
'- Аннотация @ComponentScan сканирует пакеты, который мы указали, и в нем она ищет классы с аннотациями @Component, @Repository, @Service, @Controller и @Configuration. И... она прописывается вместе с @Configuration.
 Если надо указать несколько пакетов для сканирования, то можно указать массив строк.
 Также Spring будет искать бины во всех подпакетах указанного пакета.

 Также можно указать фильтры для поиска: includeFilters и excludeFilters.
 Например: @ComponentScan.Filter(type=FilterType.CUSTOM)

 Или:  @ComponentScan(excludeFilters = @ComponentScan.Filter(type=FilterType.REGEX, pattern="com\\.baeldung\\.componentscan\\.springapp\\.flowers\\..*"))
 Для ComponentScan.Filter всего имеются пять фильтров:
 ANNOTATION,
 ASSIGNABLE_TYPE,
 ASPECTJ,
 REGEX,
 CUSTOM.
 Эти фильтры нужны для того, что например, имея какой-то ненужный класс, создать для него фильтр, чтобы его бин не инициализировался.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про аннотацию @ComponentScan.', 21);

INSERT INTO answers_spring (answer) VALUES (
'- Для работы с транзакциями Spring использует прокси Аспектно-ориентированного программирования.
 - Для того чтобы управлять транзакциями первым делом надо разместить аннотацию @EnableTransactionManagement у класса-конфигурации @Configuration.
 Если мы используем Spring Boot и имеем зависимости spring-data-* или spring-tx, то управление транзакциями будет включено по умолчанию.

 Потом мы можем использовать аннотацию @Transactional.
 - Аннотация @Transactional - она определяет область действия одной транзакции.
 - Если пометить аннотацией @Transactional какой-то класс или метод, то Spring создаст для него прокси. (Proxy - с англ. это заместитель или доверенное лицо).
 И все методы будут обернуты в транзакционную логику.

 Когда мы вызываем такой метод:
 - proxy соединяется с БД,
  - открывает в нём транзакцию и сохраняет всё это в контексте.
 - Затем, при необходимости всё это сохранённое достаётся и внедряется в бины.

 Если имеются несколько параллельных потоков, то будет и несколько параллельных транзакций, и они могут взаимодействовать между собой, согласно уровням изоляции.

 - Если один метод с @Transactional вызовет другой метод с @Transactional, то тогда второй транзакционный метод будет считаться частью первого.
 И Spring не создаст для него proxy (для второго вызываемого метода), потому что ничего не будет знать о нем.

 - Если будет выброшено исключение, и это исключение указано в контракте метода -то отката транзакции не произойдет. (если в контракте описано этоисключение)
 В транзакционном методе непроверенные(Unchecked) исключения можно ловить, а можно и не ловить.

 Также у аннотации @Transactional есть атрибут propagation: // Например: @Transactional(propagation = Propagation.MANDATORY)
 REQUIRED — применяется по умолчанию. При входе в транзакционный метод, если никакой транзакции еще нет - то будет создана новая транзакция. А иначе будет использована уже существующая транзакция.
 REQUIRES_NEW — при входе в метод, всегда создается новая транзакция, а ранее созданные транзакции приостанавливаются, пока не выйдем из метода.
 NESTED — Если текущей транзакции не существует, будет создана новая. А при входе в метод в уже существующей транзакции создаётся savepoint, который по результатам выполнения метода будет либо сохранён, либо откачен.
 MANDATORY — здесь всегда используется существующая транзакция и если текущей транзакции нет, то кидается исключение.
 SUPPORTS — если транзакции нет - то метод так и выполнится без транзакции (как обычный метод), а иначе метод будет использовать текущую транзакцию.

 NOT_SUPPORTED — при входе в метод, если есть текущая транзакция, то она будет приостановлена и метод продолжит выполняться без транзакции.

 NEVER — запрещает исполнение транзакции явно (в наглую). А если при входе в метод будет существовать транзакция, будет выброшено исключение.

 Также кроме propagation есть еще другие атрибуты:
  // Например: @Transactional(rollbackFor = Exception.class)
 rollbackFor = Exception.class - если какой-либо метод выбросит указанное исключение, то тогда контейнер откатит текущую транзакцию.
 rollbackForClassName и noRollbackForClassName - здесь имена исключений задаются в строковом виде.

 readOnly - разрешает только операции чтения.

 timeOut - Откатывает транзакции - которые не отвечают, через заданное время.

 isolation - здесь указывается уровень изолированности транзакций.

 (read committed, read uncommitted, repeatable read, serializable)

 // Распространение (Propagation) работает только если метод вызывает другой метод в другом сервисе. Если метод вызывает другой метод в этом же сервисе, то // используется this и вызов проходит мимо прокси (прокси - это заместитель). Это ограничение можно обойти при помощи самоинекции (self-injection).

 Аннотацию @Transactional - лучше всего использовать в слое Service.

 Для совершения транзакций обычно применяются такие-вот классы и интерфейсы:
 1.
 ? TransactionInterceptor. У него есть только один метод invoke(...)(с англ. вызывать). Внутри него вызывается метод класса-родителя (TransactionAspectSupport) invokeWithinTransaction(...), а в его рамках происходят все транзакции.
 ? EntityManager - это интерфейс для создания и управления сущностями в JPA.
 EntityManager - создается с помощью фабрики EntityManagerFactory. Пример: EntityManager entityManager = entityManagerFactory.createEntityManager();

 ? TransactionManager - он решает, создавать ли новую транзакцию или нет. Или - создавать ли новый EntityManager или нет.

 2. Transaction  Interceptor. (Перехватчик транзакции).

 В TransactionInterceptor код отрабатывается до момента вызова метода save(), и в нем уже будет определяется: выполнить ли метод save() в пределах уже существующей транзакции БД или стартовать новую транзакцию.
 Далее решение будет делегироваться TransactionManager-у.

 Это в том случае, если наш метод был обёрнут в блоке try-catch:

 try {

 	transaction.begin();         // логика до

 	service.save();

 	transaction.commit();      // логика после

 } catch(Exception ex) {

 	transaction.rollback();

 	throw ex;

 }

 3. TransactionManager.

 Менеджер транзакций должен предоставить ответ на два вопроса:

 ? Должен ли создаться новый EntityManager?

 ? Должна ли стартовать новая транзакция БД?


 Решение принимается, основываясь на следующих фактах:

 ? выполняется ли хоть одна транзакция в текущий момент или нет;

 ? а также на основании атрибута «propagation» в @Transactional.


 Если TransactionManager решил создать новую транзакцию, тогда:

 ? Создается новый EntityManager;

 ? EntityManager «привязывается» к текущему потоку (Thread);

 4. EntityManager proxy.

 Когда метод save() слоя Service делает вызов метода save() слоя DAO, внутри которого вызывается, например, entityManager.persist(), то не происходит вызов метода persist() напрямую у EntityManager.
 Вместо этого метод вызывает EntityManager proxy, который достает текущий EntityManager для нашего потока, и у него вызывается метод persist().


 5. Отрабатывает DAO-метод save().

 6. TransactionInterceptor.

 Отработает код после работы метода save(), а именно будет принято решение по коммиту/откату транзакции.

 Кроме того, если мы в рамках одного метода сервиса обращаемся не только к методу save(), а к разным методам Service и DAO, то все они буду работать в рамках одной транзакции, которая оборачивает этот метод сервиса.


 Если вызвать метод с @Transactional, из которого вызвать метод без @Transactional, то оба будут отработаны в рамках прокси и будут обернуты в нашу транзакционную логику.

 А если мы вызовем метод без @Transactional, из которого вызовем метод с @Transactional, то они уже не будут работать в рамках прокси и не будут обернуты в нашу транзакционную логику.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Как спринг работает с транзакциями? Расскажите про аннотацию @Transactional.', 22);

INSERT INTO answers_spring (answer) VALUES (
'>>> Контроллер - это обработчик веб-запросов.
 - @Controller - это аннотация указывает что класс является контроллером, который обрабатывает HTTP-запросы(и часто используется с аннотацией @RequestMapping)
 Методы контроллера обычно возвращают представление html-странички // или другие объекты.
 @GetMapping("/{id}")
  public Human getId(@PathVariable int id) {
  return human.findById(id);
  }

 @RestController ставится на класс-контроллер вместо @Controller. Она указывает, что этот класс обслуживает REST API и оперирует (не моделями, а) данными.
 @RestController включает в себя вот эти две аннотации: @Controller и @ResponseBody. Т.е. это не что иное, как сочетание аннотации @Controller и @ResponseBody

 //  Cледующие два фрагмента кода в Spring MVC равны:

 @Controller
 @ResponseBody
 public class MVCController {
    .. your logic
 }
 @RestController
 public class RestFulController {
   .... your logic
 }

 Метод Rest-контроллера обычно возвращает какие-то данные. На предпроджекте они у меня возвращали: return new ResponseEntity<>("Hello World!", HttpStatus.OK).
 @GetMapping("/hello")
 ResponseEntity<String> hello() {
     return new ResponseEntity<>("Hello World!", HttpStatus.OK);
 }

 Аннотация @ResponseBody сообщает контроллеру, что возвращаемый объект автоматически сериализуется в JSON или XML (используя Jackson-converter) и передается обратно в объект HttpResponse.

 Чтобы вернуть ответ со своим статусом, можно просто вернуть объект ResponseEntity. Например пишем: return ResponseEntity.status(213);

 // ResponseEntity он используется для формирования HTTP-ответа. И у него есть параметры (заголовки, код статуса и тело ответа).

 // Во всех остальных случаях достаточно использовать @ResponseBody.

 // Если мы хотим использовать ResponseEntity, то просто должны вернуть его из метода-контролера, Spring позаботится обо всем остальном.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про аннотации @Controller и @RestController. Чем они отличаются?
                                                            Как вернуть ответ со своим статусом (например 213)?', 23);

INSERT INTO answers_spring (answer) VALUES (
'- ViewResolver - это такой интерфейс, и это распознаватель представлений, он работает с представлениями(т.е. html-файлами), и поддерживает их распознавание на основе имени, которое возвращает контроллер.
 У Spring-а имеется много классов реализующих ViewResolver.
 Например:
 - InternalResourceViewResolver — это реализация ViewResolver по умолчанию. Она находит представления, которые возвращают контроллеры.
 А потом сразу переходит к этим представлениям. Поиск ведется по заданному пути, префиксу, суффиксу и имени.

 - UrlBasedViewResolver - он преобразует логические имена в URL.
  Ну тоже, похоже находит какие-то строки, только потом переводит их в URL-адреса.

 Существует также еще несколько реализаций (чтобы интегрироваться с различными технологиями представлений). Например:
 FreeMarker (FreeMarkerViewResolver), Velocity (VelocityViewResolver) и JasperReports (JasperReportsViewResolver).   '
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Что такое ViewResolver?', 24);

INSERT INTO answers_spring (answer) VALUES (
'- Model - интерфейс, который представляет коллекцию пар ключ-значение Map<String, Object>. Обычно используется в методах-контроллера. Хранит в себе модели.
 // Содержимое модели используется для отображения данных во View.

 Например, если View будет выводить информацию об объекте Human, то она может ссылаться к ключам модели, например humanName, humanPhone, и получать
 значения для этих ключей.
 Объекты-значения из модели также могут содержать бизнес-логику.

 - ModelMap - это класс, который наследуется от LinkedHashMap. Он тоже, как и Model, используется для передачи значений во Вью для визуализации представления.
 Но он передает и обрабатывает коллекцию значений, так - как будто они были были внутри Map-ы.
 Имеет все преимущества LinkedHashMap, плюс еще несколько своих собственных методов.

 - ModelAndView - является контейнером для ModelMap. Он может одновременно хранить в себе и модели и представления.
 Это позволяет контроллеру возвращать все значения как одно.


 - Получается - объект Model-и мы передаем в метод контроллера, а он уже оттуда вытаскивает все необходимые данные и посредством Thymeleaf - эти данные преобразует в наше представление html. Это я так понимаю.

 // View используется для отображения данных приложения пользователю.
  У View есть несколько поставщиков View (и они называются шаблонизаторы)
 // Например: — JSP, JSF, Thymeleaf, и т.п.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Чем отличаются Model, ModelMap и ModelAndView?', 25);

INSERT INTO answers_spring (answer) VALUES (
'- MVC — это такой шаблон проектирования. В нем программа делится на 3 вида компонентов:

 Model — модель отвечает за хранение данных.
 View — отвечает за вывод данных на фронтенде.
 Controller — он как бы стоит посерединке. Он оперирует моделями и производит обмен данными между model и view.

 Принципы MVC были созданы, чтобы — отделить всю реализацию бизнес-логики приложения (модели) от ее визуализации (view). Вот как раз - фреймворк Spring MVC этим и занимается.

 Spring MVC - это веб-фреймворк, основанный на Servlet API.  // Он использует два шаблона проектирования - Front controller и MVC.

 Spring MVC включает в себя набор важных компонентов, таких как:
 Dispatcher Servlet, Controllers, View Resolvers, Views, Models, ModelAndView, Model and Session Attributes, которые полностью независимы друг от друга.

 Основные интерфейсы, которые использует Spring MVC, для обработки запросов:
 - DispatcherServlet - это самый главный контроллер. Он получает запросы и распределяет их между другими контроллерами.
 - HandlerMapping - выбирает классы и его методы, которые должны обработать данный входящий запросы.
 - Controller — оперирует моделями и отвечает за обмен данными model с view.
 - ViewResolver. Определяет - какое именно View(представление) должно быть показано клиенту на основе имени, полученного от контроллера.
 - View. Отвечает за отображение в виде текстов и изображений. (Некоторые запросы могут идти прямо во View, не заходя в Model).

 - HandlerAdapter. Помогает DispatcherServlet вызвать и выполнить метод-контроллер для обработки входящего запроса.

 - ContextLoaderListener - это слушатель класса WebApplicationContext в Spring-e (Cлушает при старте и завершении).
 Также он связывает все жизненные циклы ApplicationContext и ServletContext, и автоматически создает ApplicationContext.

 Последовательность событий, соответствующая входящему HTTP-запросу:

 ? После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой Контроллер (Controller) должен быть вызван, после чего HandlerAdapter, отправляет запрос в нужный метод Контроллера.

 ? Контроллер принимает запрос и вызывает соответствующий метод. Вызванный метод формирует данные Model и возвращает их в DispatcherServlet вместе с именем View (как правило - это имя html-файла).

 ? При помощи интерфейса ViewResolver DispatcherServlet определяет, какое View нужно использовать на основании имени, полученного от контроллера.

 ? если это REST-запрос на сырые данные (JSON/XML), то
 DispatcherServlet сам его отправляет, минуя ViewResolver;

   ? если обычный запрос, то DispatcherServlet отправляет данные Model в виде атрибутов во View - шаблонизаторы Thymeleaf, FreeMarker и т.д., которые сами отправляют ответ.

 DispatcherServlet здесь - это ключевое звено!'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про паттерн MVC, как он реализован в Spring?', 26);

INSERT INTO answers_spring (answer) VALUES (
'- Front controller - это такой паттерн, это означает что есть какая-то единая точка входа для всех входящих запросов.
 И все http-запросы сначала обрабатываются одним главным обработчиком – DispatcherServlet (с маппингом “/”), а затем распределяет их между контроллерами.
 Он получается, выполняет сам: аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем делегирует все эти запросы другим контроллерами, которые обрабатывают разные URL. Это и есть реализация паттерна Front Controller.

 В каждом Веб-приложении может может находиться любое количество DispatcherServlet-ов. И каждый из них будет работать на своей собственной террритории(в своем собственном пространстве имен), и у каждого DispatcherServlet-а будет свой собственный WebApplicationContext с вьюшками, контроллерами и т.д.

 Потому что Spring позволяет иметь несколько контекстов одновременно.
 ? Одним из них будет корневой контекст, а все остальные контексты будут дочерними.

 ? Все дочерние контексты могут получить доступ к бинам, определенным в корневом контексте, но не наоборот.

 ? Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста. '
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про паттерн Front Controller, как он реализован в Spring?', 27);

INSERT INTO answers_spring (answer) VALUES (
'- Аспектно-ориентированное программирование (АОП) — это такая парадигма программирования, которая повышает модульность приложения за счет разделения междисциплинарных задач.
 Это когда мы можем добавить дополнительное поведение к существующему коду без изменения самого кода.

 С помощью АОП, мы можем реализовать так сказать - сквозную логику, которая применяется к множеству частей приложения - и вся эта логика может автоматически  применена ко всему приложению.

 И у Spring-а есть особый подход к АОП: т.е. он, например может (динамически) создавать прокси для всех необходимых объектов и привязывать эти объекты к к определенной конфигурирации. И затем уже будет выполняться сквозная логика.
 // Прокси - это как оболочка для какого-то объекта, или защита. Ее еще называют заместителем объекта, потому что она принимает все удары на себя.

 Например, у нас есть какая-то функциональность, и мы хотим ее внедрить в наше приложение, не изменяя ничего в нашем коде. И эта функциональность должна работать в определенных участках нашего кода, а таких участков (или модулей) может быть очень много. Получается что наша функциональность стоит где-то в сторонке, и когда мы применяем АОП, она как-бы обволакивает все выделенные участки основного кода и к каждому модулю наша функциональность применяется по отдельности. Например: мы можем залогировать отдельные участки нашего кода применяя сквозную логику АОП, и благодаря этому нам не придется прописывать в каждом участке кода LOGGER = Logger.getLogger(Main.class.getName()); LOGGER.log(Level.INFO,"Начало нашей программы!");
 // Или есть такой пример с зефиром, вафлей и шоколадом.

 Потом в АОП, есть такие понятия:
 Join point — это такие контрольные точки присоединения, которые находятся внутри основного кода, где планируется введение функциональности.
 Pointcut — это запрос точек присоединения, т.е. можно выбрать несколько этих Join point-ов (его еще называют срез) - и повесить на них Advice.
 Advice — набор инструкций выполняемых на точках среза (Pointcut), т.е. та самая сквозная логика.        Инструкции выполняются по событию разных типов:

 * Before — перед вызовом метода
 * After — после вызова метода
 * After returning — после возврата значения из метода.
 * After throwing — в случае exception
 * After finally — в случае выполнения блока finally
 * Around(вокруг) — можно вставить как - перед методом, так и после метода, а также вообще обойти вызов метода.

 И кстати, на один Pointcut можно «повесить» несколько Advice-инструкций с разными типами.

 // Вообще Aspect — это модуль в котором собраны описания Pointcut и Advice.

 Ну про аннотации я наверное ничего не смогу рассказать. Там, для всех этих операций - естественно есть аннотации, такие как:
 - @Aspect, @Pointcut, @Before, @After, и.т.д.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Что такое АОП? Как реализовано в спринге?', 28);

INSERT INTO answers_spring (answer) VALUES (
'- Filter(фильтр) - это интерфейс (из пакета javax.servlet). Он фильтрует данные запросов и ответов - либо когда запрос идет к ресурсу, либо фильтрует ответ от ресурса, либо фильтрует в обоих направлениях.

 Обычно фильтрация выполняется в методе doFilter(). У каждого фильтра есть доступ к объекту FilterConfig, в котором происходит его инициализация.
 И еще есть ссылка на ServletContext,
 который он может использовать, например, для загрузки ресурсов, необходимых для фильтрации.
 // А вообще фильтры настраиваются в дескрипторе развертывания веб-приложения.

 Также можно создавать цепочки из этих фильтров. В таком случае веб-сервер решает сам, какой фильтр вызывать первым,
 т.е.
  в каком порядке они у него зарегистрированы, в таком порядке они и будут вызываться.
 Когда в программе вызывается метод doFilter(...) первого фильтра, то веб-сервер создает объект FilterChain, внутри которого идет цепочка фильтров, и передаёт её в метод doFilter().

 - Interceptor(перехватчик) - это интерфейс (из пакета org.aopalliance.intercept), предназначенный для аспектно-ориентированного программирования.

 Когда у нас в Spring-е, запрос из ДиспетчерСервлета отправляется в Controller, перед тем как он в него попадёт, его могут перехватить вот эти вот  перехватчики Interceptor (0 или более).
 Interceptor-ы можно использовать, например для выполнения таких задач, как запись в Log, добавление или обновление конфигурации перед тем, как запрос обработается Controller-ом.

 Здесь тоже, (как и в случае с фильтрами) можно создавать цепочки перехватчиков.
 Есть такой - стек перехватчиков: и он как раз занимается связыванием перехватчиков в цепочку в каком-то определенном порядке.
 В этой цепочке перехватчиков, они тоже вызываются в том же порядке, в котором были определены изначально.

 Interceptor-ы обычно используются для выполнения какой-то логики перед тем как данные попадут в контроллер, после обработки данных в контроллере их тоже можно перехватить, и даже когда уже Представление(Вью) сформировано - интерцепторы тоже могут использоваться.
 Также с помощью Interceptor-ов мы можем вообще запретить выполнение метода контроллера. // Мы можем указать любое количество перехватчиков.

 - Listener(слушатель) - это класс, он реализует интерфейс javax.servlet.ServletContextListener.
 Он инициализируется только один раз при запуске веб-приложения и уничтожается при остановке веб-приложения.
 Чтобы создать свой Listener - надо создать класс, и имплементировать интерфейс ServletContextListener и поставить над ним аннотацию @WebListener.

 Слушатель сидит и ждет, когда произойдет указанное событие, затем «перехватывает» событие и запускает собственное событие (видимо запускает для других сллей)

 Мы можем использовать ServletContextListener - который будет запускать наш код до запуска веб-приложения.

 // В нашем веб-приложении - все ServletContextListener-ы уведомляются об инициализации и уничтожении контекста (еще до того как все фильтры и сервлеты будут
 // проинициализированы или уничтожены).

 >>> Обратный вызов функции - это когда мы в параметры одной функции передаем другую функцию, и эта другая функция тоже начинает выполняться.

 Разница - Filter vs. Interceptor.
 ? Перехватчик основан на механизме Рефлексии, а фильтр основан на обратном вызове функции.
 ? Фильтр зависит от контейнера сервлета, а перехватчик не зависит от него.
 ? Перехватчики работают только с запросами к контроллерам, а фильтры работают почти со всеми запросами (например, js, .css и т.д.).
 ? Перехватчики - могут обращаться к объектам в контейнере Spring, - а фильтры не могут. '
);
INSERT INTO questions_spring (question, answer_id) VALUES ('В чем разница между Filters, Listeners and Interceptors?', 29);

INSERT INTO answers_spring (answer) VALUES (
'Да, можно. Для этого в методе контроллера в параметрах можно указать массив или коллекцию:
http://localhost:8080/login?name=Ranga&name=Ravi&name=Sathish
public String method(@RequestParam(value=\"\"name\"\") String[] names){...}
http://localhost:8080/api/foos?id=1,2,3
public String getFoos(@RequestParam List<String> id){...}'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Можно ли передать в запросе один и тот же параметр несколько раз? Как?', 30);

INSERT INTO answers_spring (answer) VALUES (
'- Spring Security обеспечивает - защиту и безопасность. Он представляет из себя - цепочку фильтров, которые интегрированы в контейнер сервлетов.
 Этот список фильтров находится в классе FilterChainProxy.
 Он может обеспечивать аутентификацию, авторизацию и защиту от распространенных эксплойтов.

 >>> Экспло?йт — компьютерная программа, фрагмент программного кода или последовательность команд, использующие уязвимости в программном обеспечении и применяемые для проведения атаки на вычислительную систему.

 Каждый фильтр Spring Security реализует какой-то отдельный механизм безопасности.

 И этот механизм безопасности состоит из следующих блоков, т.е. классов и интерфейсов безопасности:
 Сначала идет SecurityContextHolder - это место, где Spring Security хранит информацию о том, кто аутентифицирован. Он также обеспечивает доступ к SecurityContext-у.
  В механизме Spring Security - он является самым главным и фундаментальным.

 SecurityContext - интерфейс, который обеспечивает безопасность для текущего потока. Является контейнером для объекта типа Authentication.
 (Аналог - ApplicationContext, в котором лежат бины).

 Authentication - это объект, который содержит информацию о текущем пользователе и его привилегиях. Т.е. у каждого пользователя свой объект Authentication.

 GrantedAuthority - содержит информацию о полномочиях пользователей, например, роли или уровни доступа.

 UserDetails - это интерфейс, который представляет учетную запись пользователя. Класс (модель) нашего пользователя должен его имплементировать.
 Учетная запись пользователя, которая хранится в данном интерфейсе хранит в себе такую информацию как логин, парол, роль и.т.д.
 И как раз каждый объект Authentication формируется на основании этой учетной записи, т.е. на основании UserDetalis.

 UserDetailsService - (интерфейс) он реализует загрузку данных о пользователе из хранилища. Созданный объект от этого интерфейса обращается к БД и вытаскивает оттуда юзеров. Единственный метод этого интерфейса (loadUserByUsername(String username)) принимает имя пользователя в виде String и возвращает UserDetails.

 AuthenticationManager - это основной интерфейс для аутентификации. Имеет только один метод authenticate(Authentication authentication), который срабатывает, когда пользователь пытается аутентифицироваться в системе.

 PasswordEncoder - интерфейс для шифрования/расшифровывания паролей. Это одна из реализаций - BCryptPasswordEncoder.

 Credentials(реквизиты для входа) - объект этого класса подтверждает учетную запись пользователя, но им может быть и отпечаток пальца, фото сетчатки и т.п.

 Короче, самое главное что я запомнил (из рисунка):
 Сначала идет SecurityContextHolder, внутри него (как в матрешке) лежит SecurityContext.
 Внутри SecurityContext лежит Authentication. А внутри Authentication уже лежат: Principal, Credentials и Authorities.

 Principal - интерфейс, который содержит в себе учетную запись пользователя. Authorities - хранит в себе права пользователя.

 // MODE_GLOBAL - все потоки Java-машины используют один контекст безопасности.

 // MODE_INHERITABLETHREADLOCAL - потоки порожденные от одного защищенного потока.

 Пример кода:
 @Entity
 public class User implements UserDetails {  // Создаем Юзера и имплементим его от UserDetails.

     @Override
     public Collection<? extends GrantedAuthority> getAuthorities() { // От UserDetails в этом классе переходят вот эти методы, и еще там есть методы...
         return roles;
     }

     @Override
     public String getUsername() {
         return name;
     }

 }

 @Configuration
 @EnableWebSecurity
 public class SecurityConfig extends WebSecurityConfigurerAdapter {  // Создаем класс конфигурации и экстендим его от WebSecurityConfigurerAdapter.

    @Override
     protected void configure(HttpSecurity http) throws Exception {  // Переопределяем метод configure(HttpSecurity http).
         http
                 .authorizeRequests()
                 .antMatchers("/login").anonymous()
                 .antMatchers("/","/delete/**").hasAuthority("ADMIN")
                 .antMatchers("/user").hasAuthority("USER")
                 .and()
                 .formLogin()
                 .loginPage("/login")
                 .loginProcessingUrl("/login")
                 .usernameParameter("j_email")
                 .passwordParameter("j_password")
                 .permitAll()
                 .successHandler(loginSuccessHandler);

         http.logout()
                 .permitAll()
                 .logoutRequestMatcher(new AntPathRequestMatcher("/logout"))
                 .logoutSuccessUrl("/login")
                 .and().csrf().disable();
     }
 }

 Процесс аутентификации:

 1. UsernamePasswordAuthenticationFilter получают имя пользователя и пароль и создает экземпляр класса UsernamePasswordAuthenticationToken (экземпляр интерфейса Authentication).
  // UsernamePasswordAuthenticationFilter и UsernamePasswordAuthenticationToken - классы, они реализуют интерфейс Authentication.
 2. Токен передается экземпляру AuthenticationManager для проверки.

 3. AuthenticationManager в случае успешной аутентификации, возвращает полностью заполненный экземпляр Authentication.

 4. И затем уже, через метод SecurityContextHolder.getContext().setAuthentication(...), в SecurityContext-е сохраняется возвращенный экземпляр Authentication.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются?', 31);

INSERT INTO answers_spring (answer) VALUES (
'- Spring Boot - это платформа (один из модулей Spring) для быстрой разработки автономного и производительного приложения, которое можно запустить с минимальными настройками.
 Имеет набор уже настроенных модулей, которые упрощают конфигурацию приложения, написанного на Spring.
 Здесь все настраивается автоматически, ручные настройки не требуются.
 Выбирая одну версию Spring Boot, мы неявно выбираем десятки зависимостей, которые без фреймворка пришлось бы настраивать вручную.
 Точка входа в приложение — это класс, содержащий аннотацию @SpringBootApplication и метод main().
 Spring Boot автоматически сканирует все компоненты, включенные в проект, используя аннотацию @ComponentScan .
 Имеет встроенные утилиты, которые автоматизируют процедуру настройки и ускоряют процесс создания и развертывания Spring-приложений.

 Самые важные особенности Spring Boot это - управление зависимостями, автоматическая конфигурация и встроенные контейнеры сервлетов.

 Поэтому, при использовании Spring Boot, файл pom.xml содержит намного меньше строк, чем при использовании его в обычных Spring-приложениях.
 После выбора подходящего starter-пакета, Spring Boot автоматически настраивает Spring-приложение на основе добавленных jar-зависимостей.
 Например, если добавить Spring-boot-starter-web, Boot автоматически сконфигурирует все необходимые бины для работы с веб.
 Если использовать spring-boot-starter-jdbc, Boot автоматически зарегистрирует бины для работы с б.д.
 Если нам не нужно использовать базу данных, то можно не предоставлять никаких сведений о подключении к БД, и тогда Boot автоматически настроит базу в памяти, без какой-либо конфигурации.
 Автоматическую конфигурацию можно переопределить в любой момент, это делается с помощью пользовательских настроек.
 Потом - каждое Spring Boot-приложение включает в себя встроенный web-сервер Tomcat.

 Для настройки и запуска Spring Boot приложений требуется:
 Java 8 и выше (с более ранними версиями Spring Boot не работает).
 Maven 3 и выше.
 Добавить Spring Boot плагин.
 Добавить <packaging>jar</packaging> , чтобы Maven генерировал исполняемый jar-файл при сборке проекта.
 Также, на сайте: start.spring.io можно собрать проект, просто указав необходимые стартеры.
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // Spring Boot сам знает какую версию зависимостей нужно подгружать.
 - При использовании аннотации @EnableAutoConfiguration, работающей совместно с @ComponentScan - Spring Boot настроит приложение на основе зависимостей, которые были добавлены в в pom.xml-файл.
 При использовании аннотации @SpringBootApplication, можно не добавлять аннотации: @EnableAutoConfiguration, @ComponentScan и @SpringBootConfiguration. Аннотация @SpringBootApplication включает в себя все эти аннотации.

 Чтобы ускорить процесс управления зависимостями, Spring Boot неявно упаковывает необходимые зависимости, и предоставляет их разработчику через starter-пакеты (spring-boot-starter-web, spring-boot-starter-data-jpa и т.д.)
 Starter-пакеты - это набор зависимостей, которые можно включить в свое приложение.

 Например, если нужно начать использовать Spring Data JPA, для доступа к БД, можно включить зависимость spring-boot-starter-data-jpa и все будет работать (и даже не придется искать совместимые драйверы баз данных и библиотеки Hibernate).
 Если нужно создать Spring web-приложение, можно добавить зависимость spring-boot-starter-web, которая подтянет в проект все библиотеки, необходимые для разработки Spring MVC-приложений.
 Короче, Spring Boot собирает все общие зависимости и определяет их в одном месте, что позволяет разработчикам просто их использовать, без всяких заморочек.
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

 // Чтобы включить автоматическуя конфигурацию, используется аннотацией @EnableAutoConfiguration.

 // Если наш код уже зарегистрировал бин DataSource — автоконфигурация его переопределять не будет.

 // Также Boot имеет готовые к работе функции, такие как метрики, security и внешняя конфигурация.

 Также Boot имеет инструмент CLI (command-line interface) для разработки и тестирования приложения Spring Boot.

 Также Boot поддерживает конфигурации и XML и аннотаций.

 Автоматическая конфигурация в Spring Boot происходит следующим образом:
 1. Сначала нужно отметить Main класс аннотацией @SpringBootApplication
 (эта аннотация инкапсулирует в себе: @SpringBootConfiguration, @ComponentScan, @EnableAutoConfiguration),
 И эта аннотация (
 @SpringBootApplication) запускает сканирование компонентов, запускает автоконфигурацию и показывает разным компонентам Spring, что это Spring Boot приложение.

 2. Затем нужно указать @EnableAutoConfiguration (импортирует класс EnableAutoConfigurationImportSelector). Т.е. включить автоматическую конфигурацию.

 3. Когда мы указываем @EnableAutoConfiguration - класс EnableAutoConfigurationImportSelector импортирует ВСЕ необходимые бины в контекст приложения.
 Их там более 150, и находятся они в META-INF/spring.factories конфигурации.

 4. // Каждая из этих конфигураций пытается сконфигурировать различные аспекты приложения (web, JPA, AMQP и т.д.), регистрируя нужные бины.

 5. Затем созданный AnnotationConfigEmbeddedWebApplicationContext ищет в контейнере фабрику для запуска embedded servlet container.

 6. Все. Потом Servlet container запускается, приложение готово к работе.'
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно.', 32);

INSERT INTO answers_spring (answer) VALUES (
'? Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods).
 ? Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6).
 ? Поддержка HTTP/2 (TLS, Push), NIO/NIO.2.
 ? Поддержка Kotlin.
 ? Реактивность (веб-инфраструктура с реактивным стеком, «Spring WebFlux»).
 ? Null-safety аннотации(@Nullable), новая документация.
 ? Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0).
 ? Поддержка JUnit 5 + Testing Improvements (conditional and concurrent).
 ? Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava". '
);
INSERT INTO questions_spring (question, answer_id) VALUES ('Расскажите про нововведения Spring 5.', 33);

-- src/main/resources/db/db.db.migration/V3__insert_patterns.sql
-- PATTERNS
INSERT INTO answers_patterns (answer) VALUES (
'- Шаблон (паттерн) проектирования — это шаблон по которому будет проектироваться наш проект, т.е. уже готовое и проверенное к использованию решение.
 Это означает то - как ты будешь делать(создавать) свое приложение, по какому образу и подобию.
 Это не класс и не библиотека, которую можно подключить к проекту, и шаблон проектирования может быть реализован в разных языках программирования.
 Шаблон нужен, чтобы не изобретать колесо каждый раз когда надо сделать что-то новое.

 Плюсы использования шаблонов:
 • снижение сложности разработки за счёт готовых абстракций.
 • облегчение коммуникации между разработчиками, благодаря тому что - все они ссылаются на известные шаблоны.
 • унификация всех модулей и элементов проекта, т.е. приведение их к единообразной форме.
 • если кто-то нашел хорошее решение, то есть возможность - пользоваться им снова и снова.
 • из всех вариантов, можно выбрать наиболее подходящий вариант проектирования.

 Минусы:
 • это когда кто-то применяет шаблон, там где он не нужен. И это может привести к усложнению программы.
 • когда кто-то хочет попробовать некоторый шаблон в деле без особых на то оснований. '
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Что такое «шаблон проектирования»?', 1);

INSERT INTO answers_patterns (answer) VALUES (
'- Имя - у каждого шаблона есть уникальное имя, для его идентификации;
 - Назначение, т.е. цель данного шаблона;
 - Задача, которую этот шаблон позволяет решить;
 - Способ решения, т.е. каким способом будет решаться данная задача именно в том контексте, где этот шаблон был найден;
 - Участники - это те сущности, которые принимают участие в решении задачи;
 - Следствия от использования шаблона, т.е. какой результат будет получен;
  - Реализация - это когда имеется несколько вариантов для реализации шаблона. '
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Назовите основные характеристики шаблонов.', 2);

INSERT INTO answers_patterns (answer) VALUES (
'- Порождающие паттерны. Это когда мы можем создавать какие-то объекты без внесения в программу лишних зависимостей.
 - Структурные паттерны. Это когда мы можем связывать наши объекты различными способами.
 - Поведенческие паттерны. Это когда мы можем обеспечить коммуникацию между объектами. '
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Назовите три основные группы паттернов.', 3);

INSERT INTO answers_patterns (answer) VALUES (
'- Singleton - это такой порождающий паттерн проектирования, который гарантирует, что у какого-то класса будет создан только один экземпляр,
 и он помимо этого еще сможет предоставлять глобальную точку доступа.

 У Синглтона - обычно конструктор помечается как private, а для создания нового объекта Singleton использует специальный метод (getInstance() или др.название)
 Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.

 Например в нашем классе Singlton - пишем:

 private static Singleton instance;

 public static Singleton getInstance() {
        if (instance == null) {
                    // Проверку на NULL - нужно обязательно делать, иначе каждый раз будет возвращаться новый объект.
 		instance = new Singleton();

 	}
 	return instance;
 }

 Потом, чтобы получить экземпляр класса Singlton, оператор new уже применить не получится. А придется получать синглтон из метода getInstance();

 Плюсы:   если у нас имеются какие-то ресурсоемкие задачи, то можно не создавать много объектов, а пользоваться одним.

 // Это может быть полезно для доступа к какому-то общему ресурсу, например, к базе данных.
 Минусы : то что он нарушает принцип единой ответственности SOLID, потому что его могут использовать много объектов.

 * Почему считается антипаттерном?

 - Потому что объекты Singlton нельзя тестировать с помощью mock, но можно использовать powerMock.

 - Потому что этот паттерн нарушает принцип единой ответственности SOLID.

 - Потому что этот паттерн нарушает Open/Close принцип SOLID, и из-за этого классы Singlton-ов нельзя расширить.

 * Можно ли его синхронизировать без ключевого слова synchronized у метода?

 - Можно. Для этого объект Синглтона нужно сделать Enum-ом (eager). То есть сделать статический final класс с константами.
 И так как JVM загружает final и static классы на этапе компиляции, то это означает что несколько потоков не смогут создавать несколько экземпляров класса.

 - C помощью ключевых слов double checked locking (lazy). Но в таком случае ключевое слово synchronized будет указываться внутри метода:

 private static volatile Singleton instance;

 public static Singleton getInstance() {

 	Singleton localInstance = instance;

 	if (localInstance == null) { // первая проверка
 		synchronized (Singleton.class) {
 		localInstance = instance;
 			if (localInstance == null) {
                           // вторая проверка
 				instance = localInstance = new Singleton();
 			}
 		}
 	}
     return localInstance; '
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Расскажите про паттерн Одиночка (Singleton).', 4);

INSERT INTO answers_patterns (answer) VALUES (
'- Паттерн Builder - это такой порождающий паттерн, с помощью которого можно создавать какие-то очень сложные объекты пошагово.
 И у строителя обычно, хотя внутри используется один и тот же код, но в нем можно строить самые разные объекты.

 Потом - у паттерна Строитель - объекты обычно конструируются  где-то за пределами его собственного класса, и он поручает это дело отдельным объектам,
 которые так и называются -  строители.

 Сам процесс конструирования объекта - обычно разбивается на отдельные этапы(шаги) конструирования (например, построитьСтены, вставитьДвери).
 Для того чтобы создать объект, надо поочерёдно вызывать методы строителя. И при чем не обязательно запускать все методы, а можно запускать только те,
 которые нам нужны для конструирования объекта.

 Также бывает что - методы строителя вызываются в каком-то отдельном классе, который называется Директором.
 И этот директор может задавать порядок шагов строительства, а строители будет их выполнять.

 Короче, я как понял. Что строитель можно использовать как с директором, так и без директора - но тогда мы сами будем вызывать нужные нам методы строителя.

 Плюсы: Позволяет использовать один и тот же код для создания различных объектов. А также изолирует сложный код сборки объектов от его основной бизнес-логики.

 Минусы : Усложняет код программы из-за введения дополнительных классов.'
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Расскажите про паттерн Строитель (Builder).', 5);

INSERT INTO answers_patterns (answer) VALUES (
'- Фабричный метод (Factory Method) - это такой порождающий паттерн, его еще называют виртуальный конструктор.
 Он, получается, предоставляет своим дочерним подклассам интерфейс, для создания объектов какого-то класса.
 Но решение о том - какие именно объекты, т.е объекты какого именно класса нужно создавать происходит в подклассах.
 // То есть какой-то базовый класс или интерфейс делегирует создание объектов своим классам-наследникам.

 С помощью паттерн Фабричный метод мы не создаем объекты не напрямую, используя оператор new, а объект создается через вызов особого фабричного метода.
 // Ну вот как в Синглтоне. Или например, точно также как мы бины извлекаем из контейнера в Spring-е.
 Объекты также и создаются при помощи new, но только все это происходит в фабричном методе.

 Короче, я так понял: Вот у нас есть какой-то класс, и мы этот класс имплементируется от какого-то интерфейса. И от этого интерфейса мы получаем методы, которые нужно реализовать для создания объектов какого-то класса. Т.е. внутри этих методов будут создаваться конкретные объекты.

 // Например у нас есть интерфейс Логистика и два класса: Дорожная логистика и Морская логистика.

 Обычно этот паттерн используется:
 - когда классу заранее неизвестно, объекты каких подклассов ему нужно создавать.
 - когда класс спроектирован так, чтобы объекты, которые он создаёт, определяли свое назначение внутри его подклассов. '
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Расскажите про паттерн Фабричный метод (Factory Method).', 6);

INSERT INTO answers_patterns (answer) VALUES (
'- Это такой порождающий паттерн проектирования. И он предлагает интерфейс для создания других классов. // А создавать он будет - семейства каких-то классов.
 И он не привязывается к конкретным классам создаваемых объектов.

 Паттерн Абстрактная фабрика выделяет общие интерфейсы для отдельных продуктов, составляющих семейства или группы.
 Например, когда все виды кресел реализуют интерфейс Кресло, а все диваны реализуют интерфейс Диван и так далее.

 Затем создается еще один общий интерфейс, внутри которого есть фабричные методы для создания сразу всех продуктов семейства по отдельности(например, создать Кресло, создать Диван и создать Столик).
 И эти методы возвращают не конкректные объекты, а какие-то абстрактные типы продуктов, представленные интерфейсами, которые мы выделили ранее — Кресла, Диваны и Столики.

 // Получается у нас - создаются не конкректные объекты, а абстрактные типы, т.е. семейства каких-то продуктов.

 Плюсы: Это то что гарантированно будет создаваться тип какого-то одного семейства.

 Минусы : Это то что данный паттерн - усложняет код программы из-за введения множества дополнительных классов.'
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Расскажите про паттерн Абстрактная фабрика (Abstract Factory).', 7);

INSERT INTO answers_patterns (answer) VALUES (
'- Prototype - это порождающий паттерн проектирования, который позволяет создавать объекты на основе уже ранее созданных объектов-прототипов.
 То есть - создание нового объекта происходит не через конструктор, а происходит путем клонирования от раннее созданного объекта.
 Объекты, которые поддерживают клонирование, клонируются методом clone(), который находится в Object-e. (И еще есть такой маркерный интерфейс Cloneable).
 Получается метод объекта какого-то класса создаёт новый объект этого же класса и копирует в него значения всех своих полей.

 То есть, как я понял: объект создает новый объект на основе самого себя.

 Плюсы:   Позволяет клонировать объекты, не привязываясь к их конкретным классам.

 Минусы : Сложно клонировать какие-то связанные объекты, т.е имеющие ссылки на другие объекты.  '
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Расскажите про паттерн Прототип (Prototype).', 8);

INSERT INTO answers_patterns (answer) VALUES (
'- Adapter - это структурный паттерн проектирования, который обеспечивает связь несовместимых объектов между собой.
 Например, когда есть объект-переводчик, который трансформирует данные одного объекта в такой вид, чтобы он стал понятен другому объекту.
 И при этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого.

 Применение:
 Когда например, нужно использовать сторонний класс, но его интерфейс не соответствует нашему коду приложения.
 Адаптер как-бы создает прокладку, который будет превращать реализацию кода написанного на каком-то другом языке в формат, понятный нашему языку.
 Или пример из жизни: Это когда мы USB-флэшку вставляем в разъем компьютера.

 Плюсы:   Отделяет и скрывает подробности преобразования интерфейсов объектов.
 Минусы : То что он усложняет код программы из-за введения дополнительных классов. '
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Расскажите про паттерн Адаптер (Adapter).', 9);

INSERT INTO answers_patterns (answer) VALUES (
'- Decorator это - структурный паттерн проектирования. Он оборачивает объекты в полезные обертки, и при этом добавляет им новую функциональность.
 // Например классы-обертки.
 То есть, когда какой-то объект помещается в другой объект (объект-обёртку). А тот объект-обертка - сначала запускает основное поведение обёрнутого объекта, а потом может еще добавить что-то своё, т.е. какую-то свою дополнительную функциональность.

 Оба эти объекта будут иметь общий интерфейс, и поэтому для пользователя без разницы, с каким объектом работать — с чистым или с обёрнутым.
 Прикол в том, что здесь можно использовать несколько разных обёрток одновременно — т.е. результат будет иметь объединённое поведение всех обёрток сразу.
 При использовании паттерна Декоратор состояние объекта может измениться, в отличии от паттерна Адаптера, который не менят состояния объекта.

 Плюсы:   Большая гибкость, чем у наследования.
 Минусы : Если объекты обернуты многократно, то их будет труднее конфигурировать. '
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Расскажите про паттерн Декоратор (Decorator).', 10);

INSERT INTO answers_patterns (answer) VALUES (
'Расскажите про паттерн Заместитель (Proxy).
 - Proxy - это структурный паттерн проектирования. Он короче, вместо реальных объектов, подставляет другие объекты, которые становятся его заместителями.
 И вот эти заместители - могут перехватывать запросы к оригинальному объекту. При этом они позволяют выполнить какую-то промежуточную логику: До того как вызов дойдет до оригинального-объекта или же После передачи вызова оригиналу.

 То есть паттерн Proxy - создает новые классы-дублёры, которые имеют такие же интерфейсы, что и оригинальные объекты.
 Также объект-заместитель может выполнять роль защитника оригинального объекта. Т.е. он как-бы может принимать все удары на себя.

 И при этом - пользователь или клиент, даже не будет подозревать, что имеет дело не с оригиналом а с его заместителем.

 Плюсы:   Позволяет контролировать обслуживаемый объект незаметно для клиента.
 Минусы : Увеличивает время отклика от сервиса.'
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Расскажите про паттерн Заместитель (Proxy).', 11);

INSERT INTO answers_patterns (answer) VALUES (
'- Iterator - это поведенческий паттерн проектирования. С помощью него можно последовательно обходить элементы коллекций (составных объектов), // не раскрывая их внутреннего представления.
 И благодаря такому подходу - обход коллекции происходит не в самой коллекции, а выносится в отдельный класс.

 Детали: Получается, создается объект итератор и интерфейс, который возвращает этот итератор.

 Короче, я делал так:
  Set<Integer> set = new HashSet<>();

         for(int i=0; i<10; i++){
             set.add((int) (Math.random()*(100+1)));
         }

 //        Iterator iterator = set.iterator();                              // Я делал перебор с помощью Iteratora.

 //        while(iterator.hasNext()){                                       // Так.
 //
 //            System.out.println(iterator.next());
 //        }

         for (Iterator iterator = set.iterator(); iterator.hasNext(); ){    // Или так.
             System.out.println(iterator.next());
         }'
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Расскажите про паттерн Итератор (Iterator).', 12);

INSERT INTO answers_patterns (answer) VALUES (
'- Template - это поведенческий паттерн проектирования. Это когда мы можем разбить какой-то алгоритм на последовательность шагов, а затем эти шаги мы можем описать в отдельных методах, и уже потом эти методы можем вызывать в одном ШАБЛОННОМ методе - друг за другом.
 То есть, как я понял, паттерн Template сначала определяет скелет алгоритма, затем разбивает его на отдельные шаги.
 И еще он позволяет наследникам переопределять некоторые шаги данного алгоритма, при этом структура всего алгоритма не изменяется.

 Для описания шагов можно использовать абстрактный класс. Получается общие шаги можно будет описать в абстрактном класе.
 А потом его подклассы могут переопределять некоторые шаги алгоритма, приэтом все его остальные шаги и его структура - останутся без изменений.

 Это может применяться, когда - например, у нас имеется несколько классов, делающих одно и то же, но с незначительными отличиями.
 В таком случае - общие действия могут прописываться в классе-родителе, и при необходимости могут переопределяться в классах-наследниках.

 И это позволяет убрать дублирование кода в нескольких классах с похожим поведением, но отличающихся в деталях.
 // Как я понял - речь тут идет о наследовании.)'
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Расскажите про паттерн Шаблонный метод (Template Method).', 13);

INSERT INTO answers_patterns (answer) VALUES (
'- Цепочка обязанностей - это поведенческий паттерн проектирования. Он позволяет передавать запросы последовательно - по цепочке обработчиков.
 Получается, у каждого обработчика - будут свои обязанности.
 Каждый из этих обработчиков решает, может ли он обработать запрос или нет, и стоит ли вообще этот запрос передавать дальше по цепи (следующему обработчику).

 Основная идея данного паттерна в том, чтобы каждая проверка производилась в отдельном классе, и в единственном методе.

 Происходит все это следующим образом:
 Получается, данные запроса передаваются в параметры определенного метода, и уже потом проверяются в этом методе.

 В каждом из этих методов содержится ссылка на следующий метод-обработчик. В результате - образуется цепочка методов-обработчиков со своими обязанностями.
 Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке.
 А может и не передавать, например - если проверка в одном из методов не прошла, то тогда он не передаст.

 Плюсы:  Реализует принцип единственной обязанности.
 Минусы: Запрос может остаться так никем и не обработанным.'
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Расскажите про паттерн Цепочка обязанностей (Chain of Responsibility).', 14);

INSERT INTO answers_patterns (answer) VALUES (
'- Singleton - Bean scopes.
 - Factory - Bean Factory classes.
 - Prototype - Bean scopes.
 - Adapter - Spring Web and Spring MVC.
 - Proxy - Spring Aspect Oriented Programming support.
 - Template Method - JdbcTemplate, HibernateTemplate etc.
 - Front Controller - Spring MVC DispatcherServlet. // Это один из паттернов MVC. Означает что есть какая-то единая точка входа для всех входящих запросов.
 - DAO - Spring Data Access Object support.         // Это когда создается прослойка между БД и какой-то бизнес логикой.
 - Dependency Injection. '
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Какие паттерны используются в Spring Framework?', 15);

INSERT INTO answers_patterns (answer) VALUES (
'Domain Model – это объектная модель предметной области. Она включает в себя как поведение так и данные. // Например класс User.
- Data Mapper – слой мапперов (Mappers). Это - передача данных между объектами и базой данных, сохраняя их
независимыми друг от друга.
- Proxy  — применяется для ленивой загрузки.
- Factory — используется в SessionFactory.'
);
INSERT INTO questions_patterns (question, answer_id) VALUES ('Какие паттерны используются в Hibernate?', 16);


-- src/main/resources/db/db.db.migration/V3__insert_algorithms.sql
-- ALGORITHMS
INSERT INTO answers_algorithms (answer) VALUES (
'>>> Как я понял: Алгоритмы поиска или сортировки - можно делать либо с помощью циклов, либо с помощью рекурсии.

 - Big O (O большое / символ Ландау)  - это такой символ, который описывает сложность алгоритмов. Это такое математическое обозначение функции для сравнения ее асимптотического поведения, // оно показывает темп роста функции и учитывает не только время, но и количество памяти на выполнение алгоритма.
 // Big O - показывает - как будет меняться производительность алгоритма в зависимости от роста входящих данных.   // Так сказал Пузанков. !!!!!!!!!!!!!!!
 // (Big O - дает время выполнения алгоритма при очень больших аргументах(n)). Т.е. - это сложность в худшем случае. // Так сказал Алишев.
 Т.е. - чем больше данных тем больше времени может выполняться какой-то алгоритм, и это время - также будет зависеть от устройства, и операционной системы.

 Основная цель вот этого Big O - это поиск оптимального алгоритма с наименьшим расходом по времени и по памяти.

 Асимптотика - это такой характер изменения функции при стремлении ее аргумента(N) к определённой точке. Т.е. как как именно, будет вести себя функция при прохождении к определенной точке.
 // Т.е. линия на графике - это и есть асимптотика - и Big O как раз ее и показывает.!!!!!!!!!!!!!!!!
 // Как я понял, Big O - расчитывается не по количеству времени, на выполнение алгоритма, а по количеству операций.

 И любой алгоритм - состоит из неделимых операций (процессора(шагов)), поэтому, вместо секунд, лучше всего измерять время в операциях процессора.

 // DTIME - это количество шагов(операций процессора), необходимых, чтобы алгоритм завершился.

 Временная сложность - она обычно оценивается путём подсчёта числа элементарных операций, которые выполняет алгоритм. !!!!!!!!!!!!!!!!!!
 А время исполнения одной такой операции - это константа, то есть асимптотически оценивается как O(1).

 Сложность алгоритма состоит из двух факторов: временная сложность и сложность по памяти.
 Временная сложность - функция, которая показывает зависимость количества операций процессора, от размера входных данных, ну т.е. чтобы алгоритм завершился.

 Все неделимые операции(операции сравнения, арифметические, логические, инициализации и возврата) считаются выполняемыми за 1 операцию процесора.

 (При росте N, слагаемые с меньшей скоростью роста всё меньше влияют на значение функции. Поэтому, вне зависимости от констант при слагаемых, слагаемое с большей скорость роста определяет значение функции.
 Данное слагаемое называют порядком функции. Пример: Т(N) = 5 * N^2 + 999 * N... Где (5 * N^2) и (9999 * N) являются слагаемыми функции.) - НЕ ПОНЯЛ.

 (Константы(5 и 999) не указываются в рамках нотации Big O, так как не показывают абсолютную сложность алгоритма, так как могут изменяться в зависимости от машины, поэтому сложность равна О(N^2)) - НЕ ПОНЯЛ.

 Порядок возрастания сложности:

 1. O(1) - константная, чтение по индексу из массива.
 2. O(log(n)) - логарифмическая, бинарный поиск в отсортированном массиве.
 // Где на каждой итерации берется половина элементов - это сложность O(Log n).
 3. O(vn) - сублинейная.
 4. O(n) - линейная, перебор массива в цикле, два цикла подряд, линейный поиск наименьшего или наибольшего элемента в неотсортированном массиве.
 5. O(n*log(n)) - квазилинейная, сортировка слиянием, сортировка кучей.
 6. O(n^2) - полиномиальная(квадратичная), ВЛОЖЕННЫЕ ЦИКЛЫ, перебор двумерного массива, сортировка пузырьком, сортировка вставками.
 7. O(2^n) - экспоненциальная, алгоритмы разложения на множители целых чисел. // Здесь количество операций растет как на дрожжах.
 8. O(n!) - факториальная, решение задачи коммивояжёра полным перебором.

 Алгоритм считается более таким приемлемым, если сложность не превышает O(n*log(n)), - иначе это будет считаться как говнокод.'
);
INSERT INTO questions_algorithms (question, answer_id) VALUES ('Что такое Big O? Как происходит оценка асимптотической сложности алгоритмов?', 1);

INSERT INTO answers_algorithms (answer) VALUES (
'- Рекурсия - это когда какой-то процесс является частью самого себя. Или же, говоря по простому, когда метод вызывает сам себя.
 Рекурсия состоит из базового случая и шага рекурсии. Базовый случай - это одна простая задача, которая решается за одну итерацию.
 Например: if(n == 0) return 1.

 В базовом случае должно обязательно присутствовать условие выхода из рекурсии; // Иначе получим ошибку: StackOverflow.
 Смысл рекурсии заключается в движении от исходной задачи к базовому случаю. И при этом, на каждом шаге рекурсии, размер исходной задачи уменьшается пошагово.
 После того, как будет найден базовый случай, срабатывает условие выхода из рекурсии, и стек рекурсивных вызовов разворачивается в обратном порядке.

 Пример рекурсивного вычисления факториала:

 int factorial(int n) {

 	if(n == 0) return 1;               // базовый случай с условием выхода

 	else return n * factorial(n - 1);  // шаг рекурсии (рекурсивный вызов)

 }

 >> Факториал числа - это произведение всех натуральных чисел до него включительно. Или наоборот от него до единицы: 3! = 3*2*1 = 6

 Рекурсия имеет линейную сложность O(n);

 Недостатки рекурсии:
 - Циклы дают лучшую производительность, чем рекурсивные вызовы, поскольку вызовы методов потребляют больше ресурсов, чем исполнение обычных операторов.

 - Циклы гарантируют отсутствие переполнения стека, т.к. не требуется выделения доп. памяти. А рекурсионные вызовы занимают много памяти в стэке.
 - Но - если уровней вложненности много или они могут изменяться, то лучше использовать рекурсию. А если их несколько, то тогда лучше цикл.

 >>> И кстати, как я понял: Алгоритмы поиска или сортировки - можно делать либо с помощью циклов, либо с помощью рекурсии.'
);
INSERT INTO questions_algorithms (question, answer_id) VALUES ('Что такое рекурсия? Сравните преимущества и недостатки итеративных и рекурсивных алгоритмов. С примерами.', 2);

INSERT INTO answers_algorithms (answer) VALUES (
'- Жадный алгоритм - это одна из 3-х техник создания алгоритмов.
 Вот у нас же есть 3 техники алгоритмов:  Разделяй и властвуй, Динамическое программирование и Жадные алгоритмы.

 Жадный алгоритм - это такойалгоритм, который на каждом своем шагу совершает как можно лучшее и оптимальное решение, т.е. максимально возможное из допустимых.
 И при этом, жадный алгоритм не учитывает - предыдущие или следующие шаги.

 И вот - последовательность этих локально оптимальных шагов (т.е. решений) - обычно приводит к какому-то глобальному оптимальному решению.
 Но правда это происходит не всегда, но зато в большинстве случаев.

 Т.е. наша задача рабивается на подзадачи, ииии... в каждой подзадаче принимается оптимальное решение и, в итоге, вся задача решается оптимально.

 При этом нужно учитывать, является ли каждое локальное решение безопасным шагом или нет.
 Ну а безопасный шаг - он обычно приводит к оптимальному решению безопасным путем.

 Примеры жадных алгоритмов:
 - Есть такой алгоритм Дейкстры. Там есть такой рисунок-схема, состоящий из нескольких точек(вершин), которые расположены друг от друга на разных расстояниях.
 И вот этот алгоритм Дейкстры находит кратчайший путь к каждой точке(вершине). Здесь на каждом шаге идет поиск вершины с наименьшим расстоянием(весом),
 И в итоге можно будет доказать, что кратчайшие пути, найденные в вершинах, являются оптимальными.

 - Также есть пример с автомобилем, которому нужно проехать много километров, и при этом как можно реже заезжать на заправку, чтоб заправится бензином.

 - И еще один пример: У нас есть несколько куч с золотом разной пробы, и у нас есть всего три мешка, т.е. все золото в наши мешки не поместится.
 И благодаря жадному алгоритму, можно расчитать так, - чтобы сначала, в первую очередь наполнять наши мешки золотом высшей пробы, а уже потом более низшей пробы. Потому что все равно все золото в наши мешки не поместится.'
);
INSERT INTO questions_algorithms (question, answer_id) VALUES ('Что такое жадные алгоритмы? Приведите пример.', 3);

INSERT INTO answers_algorithms (answer) VALUES (
'- Пробегаемся циклом по массиву слева направо.
 - Если текущий элемент больше следующего, меняем их местами.
 - Делаем так, пока массив не будет отсортирован.

 Короче, я делал так:

 int[] arr = {9,4,6,3,7,2,5,1};                       // Создавал массив и заполнял разными целыми числами.

         System.out.println(Arrays.toString(arr));

         boolean f = true;                            // Создавал булевую переменную.

         while (f){                                   // Которую затем использовал в цикле while в качестве аргумента.
             f = false;
             for(int i = 1; i < arr.length; i++){     // Потом в цикле while создавал еще один цикл for, и в нем перебирал наш массив.
                 if(arr[i] < arr[i-1]){               // Сравнивал, с помощью оператора if - текущий элемент со следующим.
                     int temp = arr[i];               // И если текущий элемент больше чем следующий, то менял их местами.
                     arr[i] = arr[i-1];		          // И так до тех пор - пока все не отсортируются.
                     arr[i-1] = temp;
                     f = true;
                 }
             }
         }
         System.out.println(Arrays.toString(arr));

 Aсимптотика: в лучшем случае – O(n), в худшем и среднем случае – O(n^2).'
);
INSERT INTO questions_algorithms (question, answer_id) VALUES ('Расскажите про пузырьковую сортировку.', 4);

INSERT INTO answers_algorithms (answer) VALUES (
'- Сначала нужно выбрать некоторый опорный элемент(pivot). //Я так понял желательно в центре: int average = min + (max - min) / 2;
 - Затем все элементы перекидываются, меньшие опорного элемента - налево, а большие опорного элемента – направо.
 - Для этого используются дополнительные переменные - значения слева и справа, которые сравниваются с pivot.
 - Затем с помощью рекурсии в каждой из частей, будет выбран новый pivot - и все шаги повторяются снова.

 // Короче как я понял мы делим наш массив на две части и при этом у нас есть какой-то опорный(центральный) элемент, затем меняем местами: меньшие опорного справа перекидываем налево, а большие опорного слева перекидываем налево. Затем каждую из этих частей тоже делим на две части, и повторяем пройденные шаги. Т.е. массивы разбиваются на подмассивы. И так повторяется до тех пор, пока делить будет нечего. И все это выполняется с помощью рекурсиии.

 В итоге мы получим отсортированный массив, // так как каждый элемент меньше опорного стоял раньше каждого большего опорного.

 Асимптотика:  В лучшем и среднем случае O(n*log(n)). И в худшем случае O(n^2), потому что может произойти неудачный выбор опорного элемента.'
);
INSERT INTO questions_algorithms (question, answer_id) VALUES ('Расскажите про быструю сортировку.', 5);

INSERT INTO answers_algorithms (answer) VALUES (
'- Основана на парадигме «разделяй и властвуй».
 - Сначала дробим массив пополам, пока не получим много массивов из одного элемента.
 - После чего делаем слияния: Из первых двух элементов - наименьший элемент кладем влево, наибольший элемент кладем вправо.
 - Затем берем два массива из двух элементов и минимальный элемент с лева кладем в новый массив - кладем тоже с левой стороны.
 - Затем следующие два массива проделываем все то же самое.
 - И так продолжаем делать слияния массивов из 1-го элемента в массивы по 2 элемента, затем из 2-х в 4 и т.д.
 - И так до тех пор пока все части подмассивов не сольются в один массив, но уже в отсортированном виде.

 Слияние работает по временной сложности O(n). Количество уровней зависит от log(n). А асимптотика равна O(n*log(n)).'
);
INSERT INTO questions_algorithms (question, answer_id) VALUES ('Расскажите про сортировку слиянием.', 6);

INSERT INTO answers_algorithms (answer) VALUES (
'- Бинарное дерево - это такая иерархическая структура данных, в которой каждый узел является родителем двух других узлов (двух потомков).
 Т.е. верхний узел называется родительским узлом, а нижние два (наследники) - они называются левым и правым узлами(нодами).
 Самый первый узел, у которого нет родителя - является корнем нашего дерева.
 Каждый узел в дереве создает новое поддерево, корнем которого он является. Оба поддерева — левое и правое — тоже являются бинарными деревьями.
 // Бинарное дерево - оно потому так и называется, потому что максимум может иметь только двух наследников, и не больше.
 Узлы(ноды) - у которых нет потомков, т.е. у которых ссылки на левую и правую часть деревa указывают на NULL - называются листьями такого дерева.

 Каждый узел(нода), в большинстве случаев - он состоит из ячейки с данными, и двух ссылок на следующий левый узел и на следующий правый узел.

 Также бинарное дерево - является упорядоченной структурой данных, т.е. всегда отсортированной. Элементы сортируются сразу при их добавлении.

 И у всех узлов левого поддерева значения элементов(или ключей) меньше, чем значение элемента(или ключа) самого их узла.
 И у всех узлов правого поддерева значения элементов(или ключей) больше либо равны, значению элемента(или ключа) самого узла.

 Этим как раз и достигается упорядоченная структура данных.
  И поэтому поиск элементов в бинарном дереве происходит очень быстро.

 // Ну короче, в моем понимании бинарное дерево - это просто отсортированный двухсвязный список.

 Поиск в лучшем случае - O(log(n)), худшем - O(n) // - (при вырождении в связанный список). '
);
INSERT INTO questions_algorithms (question, answer_id) VALUES ('Расскажите про бинарное дерево.', 7);

INSERT INTO answers_algorithms (answer) VALUES (
'- Красно-черное дерево - Это уже идет усовершенствованная версия бинарного дерева.
 В нем - каждый узел имеет дополнительное поле - цвет.

 И у К/ч дерева, есть такие правила:

 1) Каждый узел может быть либо черный либо красный.
 2) Корень - всегда черный.
 3) Все листья, которые не имеют узлов-наследников и не хранят данные - всегда должны быть черные.
 4) Оба потомка каждого красного узла - должны быть черными.
 5) Каждый путь от узла-предка до самого последнего узла-потомка(листа), - должен содержать одинаковое число черных узлов.
 Если вдруг оно становится не одинаковым, то тогда происходит переворот. В этом и заключается самобалансировка К/Ч дерева.

 Потому что, например: При добавлении постоянно увеличивающихся (или уменьшающихся) чисел в бинарное дерево, то там ветка продолжает расти.
 И таким образом оно вырождается в связанный список и теряет свои преимущества.
 А в к/ч дереве механизм другой:  Здесь левый и правый узлы переворачиваются, и они могут выполнять до двух поворотов.
 Поэтому и поддерживается сбалансированность, и вырождение в односвязный список не происходит - как в обычном бинарном дереве.

 При удалении происходит то же самое - узлы также переворачиваются (для соблюдения сбалансированности).
 Но только при удалении может произойти до трёх переворотов. Вот в этом то и состоит преимущство к/ч дерева над бинарным деревом.

 Здесь сложность поиска, вставки и удаления, всегда - O(log(n))'
);
INSERT INTO questions_algorithms (question, answer_id) VALUES ('Расскажите про красно-черное дерево.', 8);

INSERT INTO answers_algorithms (answer) VALUES (
'- Линейный поиск - сложность O(n), это когда все элементы проверяются по очереди.

 - Бинарный поиск - O(log(n)). Двоичный поиск — это алгоритм поиска элемента в отсортированном массиве, который использует дробление массива на половины.
 Т.е. массив должен быть отсортирован. Затем происходит поиск в массиве, необходимого элемента, по индексу.

 1) Получается, сначала мы сравниваем значение из середины массива со значением, которое мы ищем. Середина расчитывается по формуле: mid = (high + low) / 2.
 low - это будет индекс начала левого подмассива (а изначально - индекс начала массива), а high - индекс конца правого подмассива (а изначально - индекс начала массива).
 2) Если значение в середине больше значения - которое мы ищем, то переходим в левый подмассив и ищем уже там. И делаем вот-так: high = middle - 1.
 3) Если меньше, то переходим в правый подмассив и тогда поиск продолжается там. И делаем вот-так: low = middle + 1.
 4) Все это повторяется до тех пор, пока mid не страновится равен искомому элементу, либо подмассив не станет пустым.

 public static int binarySearch(int[] a, int key) {
 	int low = 0;
 	int high = a.length - 1;

 	while (low <= high) {
 		int mid = (low + high)/2;

 		if (key > a[mid]) {
 			low = mid + 1;
 		} else if (key < a[mid]) {
 			high = mid - 1;
 		} else return mid;
 	}
 	return -1;
 }

 >>> Log2(n) - В какую степень нужно возвести 2 чтобы получить N. Или сколько раз нам нужно поделить количество элементов на 2 - чтобы найти нужный элемент.

 // Двоичный поиск работает намного быстрее чем линейный. Функция логарифма растет на графике медленнее чем линейная функция.'
);
INSERT INTO questions_algorithms (question, answer_id) VALUES ('Расскажите про линейный и бинарный поиск.', 9);

INSERT INTO answers_algorithms (answer) VALUES (
'Stack это - область памяти, т.е. область хранения данных, которая находится в общей оперативной памяти (RAM).
// Считается тоже как структура данных.
// Стэк можно сравнить с магазином из пистолета.            // Я слышал что в основу входит односвязный список.
Каждый раз, когда вызывается метод, - в памяти стека создается новый так сказать блок-фрейм.
И этот блок-фрейм содержит все локальные переменные метода и ссылки на другие объекты в методе.
И как только метод заканчивает работу, блок-фрейм также перестает использоваться, после чего предоставляется
доступ для следующего метода.
Размер памяти стека намного меньше чем объем памяти в куче(в хипе). Stack работает по принципу - последний зашел,
первый вышел (LIFO).
Queue(интерфейс) - это очередь, которая обычно (но необязательно) работает по принципу - первый зашел, первый
вышел (FIFO) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди.
// Я слышал что в основу входит двухсвязный список.
// Но вот у нас есть коллекция PriorityQueue(класс), т.е. очередь с приоритетом, которая нарушает этот принцип (FIFO),
потому что использует «natural ordering». Или же использует переданный в нее Comparator при вставке нового элемента.
Потом у нас еще есть Deque(интерфейс) -это такая линейная коллекция, которая расширяет Queue. Она поддерживает
вставку и извлечение элементов с обоих концов.
То есть работает и по принципу FIFO, и по принципу LIFO.   // Интерфейс Deque реализует ArrayDeque.
И еще: в Queue и Deque методы equals() и hashCode() обычно не переопределяются, как во всех классах унаследованных
от Object-а. Они просто используются чтобы
сравнивать ссылки, но не переопределяются.'
);
INSERT INTO questions_algorithms (question, answer_id) VALUES ('Расскажите про очередь и стек.', 10);

INSERT INTO answers_algorithms (answer) VALUES (
'В большинстве случаев LinkedList проигрывает ArrayList-у. Т.е. ArrayList в большинстве случаев быстрее.
ArrayList проигрывает: / Т.е. когда лучше использовать LinkedList:
1. Когда необходимо добавлять много данных в начало или в середину списка.
2. При удалении элемента с начала (index = 0) списка.
3. .set (вставка элемента с заменой) (в конце списка или в середине списка).
LinkedList проигрывает: / Т.е. когда лучше использовать ArrayList:
1. .get (поиск элемента)  // Как говорилось в Ютубе - мы можем получить доступ к любому элементу за константное время.
2. .set (вставка элемента с заменой) (начало и середина)
3. .add (добавление элемента).
4. .remove (удаление элемента) (кроме начала списка).
Сравнение сложности:  Индекс   Поиск   Вставка   Удаление
ArrayList:  O(1)     O(n)    O(n)      O(n)
LinkedList:  O(n)     O(n)    O(1)      O(1)'
);
INSERT INTO questions_algorithms (question, answer_id) VALUES ('Сравните сложность вставки, удаления, поиска и доступа по индексу в ArrayList и LinkedList.', 11);






